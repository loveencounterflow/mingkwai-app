// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, D, LINESETTER, LODASH, LineBreaker, TEACUP, after, alert, badge, debug, echo, help, info, log, njs_fs, njs_path, rpr, sleep, step, suspend, urge, warn, whisper,
    __slice = [].slice;

  (require('guy-trace')).limit(10);

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/__dev';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  sleep = suspend.sleep;

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  TEACUP = require('coffeenode-teacup');

  LODASH = require('lodash');

  LINESETTER = require('./LINESETTER');

  LineBreaker = require('linebreak');


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /* Unchanged */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  this._render_open_tag = function(name, attributes) {
    return (this._render_empty_tag(name, attributes)).replace(/<\/[^>]+>$/, '');
  };

  this._render_close_tag = function(name) {
    return "</" + name + ">";
  };

  this._render_empty_tag = function(name, attributes) {
    return TEACUP.render((function(_this) {
      return function() {
        return TEACUP.TAG(name, attributes);
      };
    })(this));
  };

  this._break_lines = function(text, settings) {
    var R, breakpoint, extended, incremental, last_position, line_breaker, part, position, required, _ref, _ref1;
    text = text.replace(/\n/g, ' ');
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    extended = (_ref1 = settings != null ? settings['extended'] : void 0) != null ? _ref1 : false;
    line_breaker = new LineBreaker(text);
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      position = breakpoint.position, required = breakpoint.required;
      if (incremental && (last_position != null)) {
        part = text.slice(last_position, breakpoint.position);
      } else {
        part = text.slice(0, breakpoint.position);
      }
      last_position = position;
      R.push(extended ? [part, required, position] : part);
    }
    return R;
  };

  this._$break_lines = function() {
    return $((function(_this) {
      return function(event, send) {
        if (event[0] === 'text') {
          event[0] = 'text-parts';
          event[1] = _this._break_lines(event[1], {
            incremental: true
          });
        }
        return send(event);
      };
    })(this));
  };

  this._$disperse_texts = function() {
    return $((function(_this) {
      return function(event, send) {
        var tail, text_part, type, _i, _len, _ref, _results;
        type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
        if (type === 'text-parts') {
          _ref = tail[0];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            text_part = _ref[_i];
            _results.push(send(['text-part', text_part]));
          }
          return _results;
        } else {
          return send(event);
        }
      };
    })(this));
  };

  this._$correct_hyphens_etc = function() {
    return $((function(_this) {
      return function(meta_event, send) {
        var buffer, first_idx, idx, is_last, meta_type, part, replacement, text, type, _i, _ref, _ref1;
        meta_type = meta_event[0], buffer = meta_event[1], is_last = meta_event[2];
        switch (meta_type) {
          case 'test-line':
          case 'set-line':

            /* TAINT consider to move the buffer cloning to an earlier transformer. */
            meta_event[1] = buffer = LODASH.clone(buffer);
            is_last = true;
            first_idx = null;
            for (idx = _i = _ref = buffer.length - 1; _i >= 0; idx = _i += -1) {
              _ref1 = part = buffer[idx], type = _ref1[0], text = _ref1[1];
              if (part[0] === 'text-part') {
                first_idx = idx;
                replacement = is_last ? '-' : '';
                text = text.replace(/\xad$/, replacement);
                if (is_last) {
                  text = text.replace(/\s+$/, '');
                }
                text = text.replace(/&/g, '&amp;');
                text = text.replace(/</g, '&lt;');
                text = text.replace(/>/g, '&gt;');
                buffer[idx] = ['text-part', text];
              }
              is_last = false;
            }
            if (first_idx != null) {
              buffer[first_idx][1] = buffer[first_idx][1].replace(/^\s+/, '');
            }
        }
        return send(meta_event);
      };
    })(this));
  };


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /* Changed */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  this._prune_buffer = function(buffer, last_good_buffer_length) {
    var R, closed_tag_count, idx, tail, type, _i, _ref, _ref1, _ref2;
    closed_tag_count = 0;
    R = buffer.slice(0, last_good_buffer_length);
    while (R.length > 0 && ((_ref = R[R.length - 1][0]) === 'open-tag' || _ref === 'close-tag')) {
      R.pop();
    }
    last_good_buffer_length = Math.min(last_good_buffer_length, buffer.length);
    for (idx = _i = _ref1 = last_good_buffer_length - 1; _i >= 0; idx = _i += -1) {
      _ref2 = buffer[idx], type = _ref2[0], tail = 2 <= _ref2.length ? __slice.call(_ref2, 1) : [];
      switch (type) {
        case 'text-part':
        case 'empty-tag':
        case 'lone-tag':
          buffer.splice(idx, 1);
          break;
        case 'close-tag':
          buffer.splice(idx, 1);
          closed_tag_count += +1;
          break;
        case 'open-tag':
          if (closed_tag_count > 0) {
            buffer.splice(idx, 1);
            closed_tag_count += -1;
          }
          break;
        default:
          warn("1 ignored event of type " + (rpr(type)));
      }
    }
    debug('©HbYgl', R);
    return R;
  };

  this._$assemble_buffer = (function(_this) {
    return function(state) {
      var buffer, last_good_buffer_length;
      buffer = [];
      last_good_buffer_length = null;
      return $(function(event, send) {
        var good_buffer, tail, type;
        type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
        switch (type) {
          case 'open-tag':
          case 'close-tag':
            buffer.push(event);
            break;
          case 'text-part':
            buffer.push(event);
            send(['test-line', buffer]);
            break;
          case 'lone-tag':
          case 'empty-tag':
            buffer.push(event);
            send(['test-line', buffer, false]);
            break;
          case 'end':
            if (buffer.length !== 0) {
              send(['set-line', buffer]);
              buffer.length = 0;
              send(event);
            }
            break;
          default:
            warn("2 ignored event of type " + (rpr(type)));
        }
        if (state['fits']) {
          return last_good_buffer_length = buffer.length;
        } else {
          state['fits'] = true;
          good_buffer = _this._prune_buffer(buffer, last_good_buffer_length);
          warn('©FCIOb', good_buffer, buffer);
          if (good_buffer.length > 0) {
            send(['set-line', good_buffer]);
            if (buffer.length > 0) {
              send(['test-line', buffer]);
              if (state['fits']) {
                return last_good_buffer_length = buffer.length;
              } else {
                good_buffer = _this._prune_buffer(buffer, last_good_buffer_length);
                if (good_buffer.length > 0) {
                  return send(['set-line', good_buffer]);
                }
              }
            }
          } else {

            /* TAINT necessary to copy buffer? */
            send(['set-line', buffer]);
            return _this._prune_buffer(buffer, buffer.length);
          }
        }
      });
    };
  })(this);

  this._convert_to_html = function(buffer) {

    /* Note: as per
    https://medium.com/the-javascript-collection/lets-write-fast-javascript-2b03c5575d9e#1e23, using
    `+=` should be faster than `[].join ''`.
     */
    var R, event, open_tags, tag_name, tail, type, _i, _j, _len, _len1;
    R = '';
    open_tags = [];
    for (_i = 0, _len = buffer.length; _i < _len; _i++) {
      event = buffer[_i];
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      switch (type) {
        case 'open-tag':
          R += this._render_open_tag.apply(this, tail);
          open_tags.unshift(tail[0]);
          break;
        case 'close-tag':
          R += this._render_close_tag(tail[0]);
          open_tags.shift();
          break;
        case 'lone-tag':
          R += this._render_open_tag.apply(this, tail);
          break;
        case 'empty-tag':
          R += this._render_empty_tag.apply(this, tail);
          break;
        case 'text-part':

          /* TAINT escaping `<`, `>`, `&` ??? */
          R += tail[0];
          break;
        default:
          warn("3 ignored event of type " + (rpr(type)));
      }
    }
    for (_j = 0, _len1 = open_tags.length; _j < _len1; _j++) {
      tag_name = open_tags[_j];
      R += this._render_close_tag(tag_name);
    }
    return R;
  };

  this._$convert_to_html = function(state) {
    return $((function(_this) {
      return function(meta_event, send) {
        var buffer, html, is_last, meta_type;
        meta_type = meta_event[0], buffer = meta_event[1], is_last = meta_event[2];
        switch (meta_type) {
          case 'test-line':
          case 'set-line':
            html = _this._convert_to_html(buffer);
            return send([meta_type, html, is_last]);
          default:
            return send(meta_event);
        }
      };
    })(this));
  };

  this._$test_line = (function(_this) {
    return function(state, test_line) {

      /* test line */
      return $(function(event, send) {
        var line, type;
        type = event[0], line = event[1];
        if (type === 'test-line') {
          state['fits'] = test_line(line);
        }
        return send(event);
      });
    };
  })(this);

  this.demo_5 = function() {
    var input, set_line, set_lines, state, test_line, text;
    input = D.create_throughstream();
    state = {
      fits: true,
      is_first_line: true,
      is_last_line: false
    };
    set_lines = (function(_this) {
      return function(text, test_line, set_line) {
        input.pipe(D.HTML.$parse()).pipe(D.HTML.$collect_texts()).pipe(D.HTML.$collect_empty_tags()).pipe(_this._$break_lines()).pipe(_this._$disperse_texts()).pipe(_this._$assemble_buffer(state)).pipe(_this._$correct_hyphens_etc()).pipe(_this._$convert_to_html(state)).pipe(_this._$test_line(state, test_line)).pipe($(function(event, send) {
          var line, type;
          type = event[0], line = event[1];
          switch (type) {
            case 'test-line':
              if (state['fits']) {
                urge(line);
              } else {
                warn(line);
              }
              break;
            case 'set-line':
              help(line);
          }
          return send(event);
        }));
        input.write(text);
        return input.end();
      };
    })(this);
    test_line = function(line) {
      return line.length < 12;
    };
    set_line = function(line, is_first, is_last) {
      urge(line);
      return null;
    };
    text = "<i>a <b>b</b> c d</i> e <img src='x.jpg'> f g h";
    return set_lines(text, test_line, set_line);
  };

  if (module.parent == null) {
    this.demo_5();
  }

}).call(this);
