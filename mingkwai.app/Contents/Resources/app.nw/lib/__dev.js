// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, D2, LINESETTER, LODASH, LineBreaker, after, alert, badge, debug, echo, help, info, log, njs_fs, njs_path, rpr, sleep, step, suspend, urge, warn, whisper,
    __slice = [].slice;

  (require('guy-trace')).limit(10);

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/__dev';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  sleep = suspend.sleep;

  D2 = require('pipedreams2');

  $ = D2.remit.bind(D2);

  LODASH = require('lodash');

  LINESETTER = require('./LINESETTER');

  LineBreaker = require('linebreak');

  this._break_lines = function(text, settings) {
    var R, breakpoint, extended, incremental, last_position, line_breaker, part, position, required, _ref, _ref1;
    text = text.replace(/\n/g, ' ');
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    extended = (_ref1 = settings != null ? settings['extended'] : void 0) != null ? _ref1 : false;
    line_breaker = new LineBreaker(text);
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      position = breakpoint.position, required = breakpoint.required;
      if (incremental && (last_position != null)) {
        part = text.slice(last_position, breakpoint.position);
      } else {
        part = text.slice(0, breakpoint.position);
      }
      last_position = position;
      R.push(extended ? [part, required, position] : part);
    }
    return R;
  };

  this._$break_lines = function() {
    return $((function(_this) {
      return function(event, send) {
        if (event[0] === 'text') {
          event[0] = 'text-parts';
          event[1] = _this._break_lines(event[1], {
            incremental: true
          });
        }
        return send(event);
      };
    })(this));
  };

  this._$disperse_texts = function() {
    return $((function(_this) {
      return function(event, send) {
        var tail, text_part, type, _i, _len, _ref, _results;
        type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
        if (type === 'text-parts') {
          _ref = tail[0];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            text_part = _ref[_i];
            _results.push(send(['text-part', text_part]));
          }
          return _results;
        } else {
          return send(event);
        }
      };
    })(this));
  };

  this.demo_4 = function() {
    var input, prune_buffer, state, test_line, text;
    input = D2.create_throughstream();
    state = {
      fits: true
    };
    prune_buffer = function(buffer) {

      /* TAINT in reality more complicated; should store last good buffer length */
      var R;
      R = buffer.splice(0, Math.max(1, buffer.length - 1));
      return R;
    };
    test_line = function(line) {
      return line.length < 7;
    };
    input.pipe(this._$break_lines()).pipe(this._$disperse_texts()).pipe((function(_this) {
      return function() {

        /* assemble buffer */
        var buffer;
        buffer = [];
        return $(function(event, send) {
          var length, ok_buffer, text, type;
          type = event[0], text = event[1];
          switch (type) {
            case 'text-part':
              buffer.push(text);
              send(['test-line', buffer]);
              break;
            case 'end':
              if (buffer.length !== 0) {
                send(['set-line', buffer]);
                buffer.length = 0;
                send(event);
              }
              break;
            default:
              warn("ignored event of type " + (rpr(type)));
          }
          if (!state['fits']) {
            state['fits'] = true;
            ok_buffer = prune_buffer(buffer);
            send(['set-line', ok_buffer]);
            if (buffer.length > 0) {
              send(['test-line', buffer]);
              if (!(length = buffer.length === 1)) {
                throw new Error("expected buffer of length 1, is " + length);
              }
              if (!state['fits']) {
                ok_buffer = prune_buffer(buffer);
                return send(['set-line', ok_buffer]);
              }
            }
          }
        });
      };
    })(this)()).pipe((function(_this) {
      return function() {

        /* build line */
        return $(function(event, send) {
          var buffer, type;
          type = event[0], buffer = event[1];
          if (type === 'test-line') {
            return send(['test-line', buffer.join('')]);
          } else {
            return send(event);
          }
        });
      };
    })(this)()).pipe((function(_this) {
      return function() {

        /* test line */
        return $(function(event, send) {
          var line, type;
          type = event[0], line = event[1];
          if (type === 'test-line') {
            return state['fits'] = test_line(line);
          } else {
            return send(event);
          }
        });
      };
    })(this)()).pipe(D2.$show());
    text = "a bbbbbbbbbbbb c d e ff g h";
    input.write(['text', text]);
    input.write(['end']);
    return input.end();
  };

  this.demo_5 = function() {
    var input, prune_buffer, state, test_line, text;
    input = D2.create_throughstream();
    state = {
      fits: true
    };
    prune_buffer = function(buffer) {

      /* TAINT in reality more complicated; should store last good buffer length */
      var R;
      R = buffer.splice(0, Math.max(1, buffer.length - 1));
      return R;
    };
    test_line = function(line) {
      return line.length < 7;
    };
    input.pipe(this._$break_lines()).pipe(this._$disperse_texts()).pipe((function(_this) {
      return function() {

        /* assemble buffer */
        var buffer;
        buffer = [];
        return $(function(event, send) {
          var length, ok_buffer, text, type;
          type = event[0], text = event[1];
          switch (type) {
            case 'text-part':
              buffer.push(text);
              send(['test-line', buffer]);
              break;
            case 'end':
              if (buffer.length !== 0) {
                send(['set-line', buffer]);
                buffer.length = 0;
                send(event);
              }
              break;
            default:
              warn("ignored event of type " + (rpr(type)));
          }
          if (!state['fits']) {
            state['fits'] = true;
            ok_buffer = prune_buffer(buffer);
            send(['set-line', ok_buffer]);
            if (buffer.length > 0) {
              send(['test-line', buffer]);
              if (!(length = buffer.length === 1)) {
                throw new Error("expected buffer of length 1, is " + length);
              }
              if (!state['fits']) {
                ok_buffer = prune_buffer(buffer);
                return send(['set-line', ok_buffer]);
              }
            }
          }
        });
      };
    })(this)()).pipe((function(_this) {
      return function() {

        /* build line */
        return $(function(event, send) {
          var buffer, type;
          type = event[0], buffer = event[1];
          if (type === 'test-line') {
            return send(['test-line', buffer.join('')]);
          } else {
            return send(event);
          }
        });
      };
    })(this)()).pipe((function(_this) {
      return function() {

        /* test line */
        return $(function(event, send) {
          var line, type;
          type = event[0], line = event[1];
          if (type === 'test-line') {
            return state['fits'] = test_line(line);
          } else {
            return send(event);
          }
        });
      };
    })(this)()).pipe(D2.$show());
    text = "a bbbbbbbbbbbb c d e ff g h";
    input.write(['text', text]);
    input.write(['end']);
    return input.end();
  };

  this.demo_6 = function() {
    var add_prefix, add_suffix, input, text, transforms;
    add_prefix = $((function(_this) {
      return function(event, send) {
        var text;
        if (CND.isa_text((text = event[1]))) {
          event[1] = '*' + text;
        }
        return send(event);
      };
    })(this));
    add_suffix = $((function(_this) {
      return function(event, send) {
        var text;
        if (CND.isa_text((text = event[1]))) {
          event[1] = text + '*';
        }
        return send(event);
      };
    })(this));
    text = "a bbbbbbbbbbbb c d e ff g h";
    transforms = [this._$break_lines(), this._$disperse_texts(), add_prefix, add_suffix, D2.$show()];
    input = D2.create_throughstream();
    input.pipe(D2.$link(transforms)).pipe($(function(data, send) {
      urge(data);
      return send(data);
    }));
    input.write(['text', text]);
    input.write(['end']);
    return input.end();
  };

  if (module.parent == null) {
    this.demo_4();
  }

}).call(this);
