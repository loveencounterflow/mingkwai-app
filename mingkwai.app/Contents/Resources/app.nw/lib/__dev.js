// Generated by CoffeeScript 1.9.0
(function() {
  var $, $break_lines, $collect_closing_tags, $collect_empty_tags, $collect_texts, $hyphenate, $test_lines, CND, D, D2, LODASH, TEACUP, alert, badge, debug, echo, help, info, log, njs_fs, njs_path, render_close_tag, render_empty_tag, render_open_tag, rpr, urge, warn, whisper, _XXX_id,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  (require('guy-trace')).limit(10);

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/browser';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  D2 = require('pipedreams2');

  D = require('pipedreams');

  $ = D2.remit.bind(D2);

  TEACUP = require('coffeenode-teacup');

  _XXX_id = (require('jsoid')).new_jsoid();

  LODASH = require('lodash');

  D2.new_hyphenator = function(hyphenation, min_length) {
    var HYPHER, Hypher;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 4;
    }

    /* https://github.com/bramstein/hypher */
    Hypher = require('hypher');
    if (hyphenation == null) {
      hyphenation = require('hyphenation.en-us');
    }
    HYPHER = new Hypher(hyphenation);
    return HYPHER.hyphenateText.bind(HYPHER);
  };

  D2.$hyphenate = function(hyphenation, min_length) {
    var hyphenate;
    if (hyphenation == null) {
      hyphenation = null;
    }
    if (min_length == null) {
      min_length = 4;
    }
    hyphenate = this.new_hyphenator(hyphenation, min_length);
    return $((function(_this) {
      return function(text, send) {
        return send(hyphenate(text, min_length));
      };
    })(this));
  };

  D2.break_lines = function(text, settings) {
    var LineBreaker, R, breakpoint, extended, incremental, last_position, line_breaker, part, position, required, _ref, _ref1;
    LineBreaker = require('linebreak');
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    extended = (_ref1 = settings != null ? settings['extended'] : void 0) != null ? _ref1 : false;
    line_breaker = new LineBreaker(text);
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      position = breakpoint.position, required = breakpoint.required;
      if (incremental && (last_position != null)) {
        part = text.slice(last_position, breakpoint.position);
      } else {
        part = text.slice(0, breakpoint.position);
      }
      last_position = position;
      R.push(extended ? [part, required, position] : part);
    }
    return R;
  };

  D2.$break_lines = function(settings) {

    /* Uses the [linebreak](https://github.com/devongovett/linebreak) module to find line break opportunities
    in a text using the Unicode Line Breaking Algorithm (UAX #14). For each text that arrives in the stream,
    `$break_lines` will send out one ore more 'events' (lists) of the format
    
    ```
    [ 'line-breaker-part', idx, part, required, position, ]
    ```
    
    where the first part identifies the event type, `idx` is a running enumeration of texts that have arrived,
    `part` is part of the text in question, `required` indicates whether a line break after that part is
    optional or required, and `position` contains the index of the first character *after* the current `part`.
    
    When `incremental` is set to `true`, then `part` will be the next substring after which a linebreak is
    possible; when `incremental` is set to `false` (the default), then `part` will contain the entire
    text up to the breakpoint; therefore, given a text `'So. Here we go!'`, the events will be either
    (with `incremental` set to `false`):
    
    ```coffee
    [ 'line-breaker-part', 0, 'So. ', false, 4 ]
    [ 'line-breaker-part', 0, 'Here ', false, 9 ]
    [ 'line-breaker-part', 0, 'we ', false, 12 ]
    [ 'line-breaker-part', 0, 'go!', false, 15 ]
    [ 'line-breaker-part', 0, null, null, null ]
    ```
    
    or (with `incremental` set to `true`):
    
    ```coffee
    [ 'line-breaker-part', 0, 'So. ', false, 4 ]
    [ 'line-breaker-part', 0, 'So. Here ', false, 9 ]
    [ 'line-breaker-part', 0, 'So. Here we ', false, 12 ]
    [ 'line-breaker-part', 0, 'So. Here we go!', false, 15 ]
    [ 'line-breaker-part', 0, null, null, null ]
    ```
     */

    /* https://github.com/devongovett/linebreak */
    var LineBreaker, idx, incremental, last_position, _ref;
    LineBreaker = require('linebreak');
    idx = -1;
    last_position = null;
    incremental = (_ref = settings != null ? settings['incremental'] : void 0) != null ? _ref : true;
    return $((function(_this) {
      return function(text, send) {
        var breakpoint, line_breaker, part, position, required;
        idx += +1;
        line_breaker = new LineBreaker(text);
        breakpoint = null;
        while (breakpoint = line_breaker.nextBreak()) {
          position = breakpoint.position, required = breakpoint.required;
          if (incremental && (last_position != null)) {
            part = text.slice(last_position, breakpoint.position);
          } else {
            part = text.slice(0, breakpoint.position);
          }
          last_position = position;
          send(['line-breaker-part', idx, part, required, position]);
        }
        return send(['line-breaker-part', idx, null, null, null]);
      };
    })(this));
  };

  D2._new_html_parser = function(settings, stream) {

    /* NB.: Will not send empty text nodes; will not join ('normalize') adjacent text nodes. */
    var Htmlparser, handlers, lone_tags;
    lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);
    handlers = {
      onopentag: function(name, attributes) {
        if (__indexOf.call(lone_tags, name) >= 0) {
          if (name === 'wbr') {
            if ((Object.keys(attributes)).length > 0) {
              throw new Error("illegal <wbr> tag with attributes");
            }

            /* as per https://developer.mozilla.org/en/docs/Web/HTML/Element/wbr */
            return stream.write(['text', '\u200b']);
          } else {
            return stream.write(['lone-tag', name, attributes]);
          }
        } else {
          return stream.write(['open-tag', name, attributes]);
        }
      },
      onclosetag: function(name) {
        if (__indexOf.call(lone_tags, name) < 0) {
          return stream.write(['close-tag', name]);
        }
      },
      ontext: function(text) {
        return stream.write(['text', text]);
      },
      onend: function() {
        stream.write(['end']);
        return stream.end();
      },
      onerror: function(error) {
        throw error;
      }
    };
    Htmlparser = (require('htmlparser2')).Parser;
    return new Htmlparser(handlers, settings);
  };

  D2.$parse_html = function() {
    var html_parser, settings, stream, _send;
    settings = {
      decodeEntities: true
    };
    stream = D2.create_throughstream();
    html_parser = this._new_html_parser(settings, stream);
    _send = null;
    stream.on('data', function(data) {
      return _send(data);
    });
    stream.on('end', function() {
      return _send.end();
    });
    return $((function(_this) {
      return function(source, send, end) {
        _send = send;
        if (source != null) {
          html_parser.write(source);
        }
        if (end != null) {
          return html_parser.end();
        }
      };
    })(this));
  };

  $collect_closing_tags = function() {

    /* Keeps trace of all opened tags and adds a list to each event that speels out the names of tags to be
    closed at that point; that list anticipates all the `close-tag` events that are due to arrive later in the
    stream.
     */
    var pending_tag_buffer;
    pending_tag_buffer = [];
    return $(function(event, send) {
      var tail, type;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'open-tag') {
        pending_tag_buffer.unshift(tail[0][0]);
      } else if (type === 'close-tag') {
        pending_tag_buffer.shift();
      }
      if (type !== 'end') {
        event.push(pending_tag_buffer.slice(0));
      }
      return send(event);
    });
  };

  $collect_texts = function() {
    var send_buffer, text_buffer, _send;
    text_buffer = [];
    _send = null;
    send_buffer = function() {
      if (text_buffer.length > 0) {
        _send(['text', text_buffer.join('')]);
        return text_buffer.length = 0;
      }
    };
    return $(function(event, send) {
      var tail, type;
      _send = send;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'text') {
        return text_buffer.push(tail[0]);
      } else {
        send_buffer();
        return send(event);
      }
    });
  };

  $collect_empty_tags = function() {

    /* Detects situations where an openening tag is directly followed by a closing tag, such as in `foo
    <span class='x'></span> bar`, and turns such occurrances into single `empty-tag` events to simplifiy
    further processing.
     */
    var last_event;
    last_event = null;
    return $(function(event, send) {
      var tail, type;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'open-tag') {
        if (last_event != null) {
          send(last_event);
        }
        last_event = event;
        return;
      }
      if (type === 'close-tag' && (last_event != null)) {
        send(['empty-tag'].concat(__slice.call(last_event.slice(1))));
        last_event = null;
        return;
      }
      if (last_event != null) {
        send(last_event);
        last_event = null;
      }
      return send(event);
    });
  };

  $hyphenate = function() {
    var P, hyphenate;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    hyphenate = D2.new_hyphenator.apply(D2, P);
    return $(function(event, send) {
      if (event[0] === 'text') {
        event[1] = hyphenate(event[1]);
      }
      return send(event);
    });
  };

  $break_lines = function() {
    return $(function(event, send) {
      if (event[0] === 'text') {
        event[0] = 'text-parts';
        event[1] = D2.break_lines(event[1], {
          incremental: true
        });
      }
      return send(event);
    });
  };

  $test_lines = function(state) {
    var buffer, xxxxx;
    buffer = [];
    xxxxx = false;
    return $((function(_this) {
      return function(event, send) {
        var close_tags, idx, tail, text_part, text_parts, type, _i, _len;
        type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
        if (xxxxx) {
          return;
        }
        switch (type) {
          case 'open-tag':
          case 'close-tag':
            buffer.push(event);
            break;
          case 'text-parts':
            text_parts = tail[0], close_tags = tail[1];
            for (idx = _i = 0, _len = text_parts.length; _i < _len; idx = ++_i) {
              text_part = text_parts[idx];
              buffer.push(text_part);
              debug('©REf0J', JSON.stringify(buffer), state['next']);
              if (state['next']) {
                break;
              }
              send(buffer);
            }
            break;
          case 'empty-tag':
          case 'lone-tag':
            buffer.push(event);
            send(buffer);
            break;
          default:
            warn('A', "ignored event of type " + (rpr(type)));
        }
        if (state['next']) {
          return xxxxx = true;
        }
      };
    })(this));
  };


  /* -> LINESETTER */

  render_open_tag = function(name, attributes) {
    return (render_empty_tag(name, attributes)).replace(/<\/[^>]+>$/, '');
  };

  render_close_tag = function(name) {
    return "</" + name + ">";
  };

  render_empty_tag = function(name, attributes) {

    /* NB `teacup` has a bug (IMHO) that causes it to modify the `attributes` object when rendering; to
    prevent it from modifying buffered elements, we always pass it a copy of the `attributes` POD.
     */
    return TEACUP.render((function(_this) {
      return function() {
        return TEACUP.TAG(name, LODASH.clone(attributes));
      };
    })(this));
  };

  this.demo_3 = function() {
    var input, text;
    text = "So. Here we go!";
    text = "Just as she <b><i>said</i></b> this, she noticed that <i>one of the trees had a door\nleading right into it.</i> 'That's very curious!' she thought. 'But\neverything's curious today. I think I may as well go in at once.' And in\nshe &#x4e00; went.";
    text = "x <span class='x'></span> y";
    text = "<i>It's <b>very</b> supercalifragilistic</i>, http://<wbr>x.com <span class='x'></span>she explained.";
    input = D2.create_throughstream();
    input.pipe(D2.$parse_html()).pipe($collect_texts()).pipe($collect_empty_tags()).pipe($hyphenate()).pipe($break_lines()).pipe(D2.$sub(function(source, sink, state) {
      return source.pipe($test_lines(state)).pipe((function(_this) {
        return function() {
          var line;
          line = [];
          return $(function(line_parts, send) {
            var chr_count, idx, last_line, line_part, open_tag, open_tags, tail, type, _i, _j, _len, _len1, _ref, _ref1;
            chr_count = 0;
            open_tags = [];
            line = [];
            last_line = null;
            if (((_ref = line_parts[1]) != null ? _ref[2] : void 0) != null) {
              if ((_ref1 = line_parts[1]) != null) {
                _ref1[2]['foo'] = 'baz';
              }
            }
            for (idx = _i = 0, _len = line_parts.length; _i < _len; idx = ++_i) {
              line_part = line_parts[idx];
              if (CND.isa_text(line_part)) {
                line.push(line_part);
                chr_count += line_part.length;
              } else {
                type = line_part[0], tail = 2 <= line_part.length ? __slice.call(line_part, 1) : [];
                switch (type) {
                  case 'open-tag':
                    line.push(render_open_tag.apply(null, tail));
                    open_tags.unshift(line_part[1]);
                    break;
                  case 'close-tag':
                    line.push(render_close_tag(tail[0]));
                    open_tags.shift();
                    break;
                  case 'lone-tag':
                    line.push(render_open_tag.apply(null, tail));
                    break;
                  case 'empty-tag':
                    line.push(render_empty_tag.apply(null, tail));
                    break;
                  default:
                    warn('B', "ignored event of type " + (rpr(type)));
                }
              }
            }
            if (chr_count > 15) {
              state['next'] = true;
              source.write(['next']);
            }
            for (_j = 0, _len1 = open_tags.length; _j < _len1; _j++) {
              open_tag = open_tags[_j];
              line.push(render_close_tag(open_tag));
            }
            return urge('©TNH8e', chr_count, line != null ? line.join('') : '### no line yet ###');
          });
        };
      })(this)()).pipe(sink);
    })).pipe(D2.$show());
    input.write(text);
    return input.end();
  };

  this.demo_1 = function() {
    var input, text;
    text = "So. Here we go!";
    text = "It's supercalifragilistic, she explained.";
    text = "Just as she said this, she noticed that one of the trees had a door\nleading right into it. 'That's very curious!' she thought. 'But\neverything's curious today. I think I may as well go in at once.' And in\nshe went.";
    input = D2.create_throughstream();
    input.pipe(D2.$hyphenate()).pipe(D2.$sub(function(source, sink) {
      return source.pipe(D2.$break_lines({
        incremental: true
      })).pipe((function(_this) {
        return function() {
          var chr_count, line;
          line = [];
          chr_count = 0;
          return $(function(event, send) {
            var idx, part, position, required, type;
            type = event[0], idx = event[1], part = event[2], required = event[3], position = event[4];
            if (type === 'line-breaker-part') {
              if (part != null) {
                chr_count += part.length;
                if (chr_count > 25) {
                  send(line.join(''));
                  line.length = 0;
                  chr_count = part.length;
                }
                return line.push(part);
              } else {
                if (line.length > 0) {
                  send(line.join(''));
                }

                /* TAINT not correct with multiple texts? */
                return source.end();
              }
            } else {
              return send(event);
            }
          });
        };
      })(this)()).pipe($((function(_this) {
        return function(line, send) {
          help(line.replace(/\s+/g, ' '));
          return send(line);
        };
      })(this))).pipe(sink);
    }));
    input.write(text);
    return input.end();
  };

  this.demo_2 = function() {
    var epsilon, has_ended, input, n, _i, _len, _ref;
    input = D2.create_throughstream();
    epsilon = 0.1;
    has_ended = {};
    input.pipe(D2.$sub(function(source, sink, XXX_end) {
      return source.pipe($(function(n, send) {
        return send(Math.sqrt(n));
      })).pipe($(function(n, send) {
        whisper("(" + n + ")");
        if ((Math.abs(n - 1)) < epsilon) {
          send(n);
          if (source.ended) {
            return source.end();
          }
        } else {
          return source.write(n);
        }
      })).pipe(sink);
    })).pipe(D2.$show()).pipe(D.$on_end(function() {
      return urge('ok');
    }));
    _ref = [3, 4, 1e6, 0.1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      input.write(n);
    }
    return input.end();
  };

  if (module.parent == null) {
    this.demo_3();
  }

}).call(this);
