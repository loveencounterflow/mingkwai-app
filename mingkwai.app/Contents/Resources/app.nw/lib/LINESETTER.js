// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, D, HOTMETAL, XCSS, after, alert, badge, debug, echo, glyph_replacements, help, immediately, info, log, now, rpr, sleep, step, suspend, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/LINESETTER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  immediately = suspend.immediately;

  sleep = suspend.sleep;

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  HOTMETAL = D.HOTMETAL;

  XCSS = require('./XCSS');

  glyph_replacements = require('./glyph-replacements');


  /* https://github.com/meryn/performance-now */

  now = require('performance-now');

  this.demo = function(app, md, settings, handler) {
    var BD, MKTS, arity, as_html, document, format, gcolumn, gcolumn_left, gcolumn_offset, gcolumn_top, input, jQuery, live, mark_chrs, mark_lines, matter, mm_from_npx, mm_from_rpx, npx_from_mm, rpx_from_mm, t0, window, zoomer, ƒ, _ref;
    debug('©E054j', 'demo');
    switch (arity = arguments.length) {
      case 3:
        handler = settings;
        settings = {};
        break;
      case 4:
        null;
        break;
      default:
        throw new Error(" expected 3 or 4 arguments, got " + arity);
    }
    switch (format = (_ref = settings['format']) != null ? _ref : 'md') {
      case 'md':
        as_html = D.MD.$as_html();
        break;
      case 'html':
        as_html = D.$pass_through();
        break;
      default:
        return handler(new Error("unknown format " + (rpr(format))));
    }
    matter = app['matter'];
    jQuery = app['jQuery'];
    MKTS = app['MKTS'];
    window = app['window'];
    document = window['document'];
    BD = window['BD'];
    gcolumn = (jQuery('galley column')).eq(0);
    gcolumn_offset = gcolumn.offset();
    gcolumn_left = gcolumn_offset['left'];
    gcolumn_top = gcolumn_offset['top'];
    zoomer = jQuery('zoomer');
    window.gcolumn = gcolumn;
    input = D.create_throughstream();
    mm_from_rpx = function(d) {
      return MKTS.GAUGE.mm_from_rpx(app, d);
    };
    mm_from_npx = function(d) {
      return MKTS.GAUGE.mm_from_npx(app, d);
    };
    rpx_from_mm = function(d) {
      return MKTS.GAUGE.rpx_from_mm(app, d);
    };
    npx_from_mm = function(d) {
      return MKTS.GAUGE.npx_from_mm(app, d);
    };
    ƒ = function(x, precision) {
      if (precision == null) {
        precision = 2;
      }
      return x.toFixed(precision);
    };
    live = true;
    live = false;
    mark_chrs = true;
    mark_lines = false;
    t0 = +new Date();
    input.pipe(as_html).pipe((function(_this) {
      return function() {

        /* TAINT temporary fix for CJK Ext. B-related bug; see
        https://productforums.google.com/forum/#!category-topic/chrome/report-a-problem-and-get-troubleshooting-help/mac/Stable/_bLJl0pNS4Y
        Regex matches CJK Ext. B codepoints; constructed using http://apps.timwhitlock.info/js/regex.
        Also see https://github.com/mathiasbynens/regenerate.
         */
        var matcher;
        matcher = /([\ud840-\ud868][\udc00-\udfff]|\ud869[\udc00-\udede]+)/g;
        return $(function(html, send) {
          return send(html.replace(matcher, '<cjkxbfix>$1</cjkxbfix>'));
        });
      };
    })(this)()).pipe(D.HTML.$split({
      disperse: true,
      hyphenation: true,
      whitespace: false,
      chrs: true
    })).pipe((function(_this) {
      return function() {
        return $(function(tags_and_chrs, send) {
          var chr, chr_idx, element_idx, text_element, _i, _j, _len, _ref1, _ref2;
          for (element_idx = _i = 1, _ref1 = tags_and_chrs.length; _i < _ref1; element_idx = _i += +2) {
            text_element = tags_and_chrs[element_idx];
            for (chr_idx = _j = 0, _len = text_element.length; _j < _len; chr_idx = ++_j) {
              chr = text_element[chr_idx];
              text_element[chr_idx] = (_ref2 = glyph_replacements[chr]) != null ? _ref2 : chr;
            }
          }
          return send(tags_and_chrs);
        });
      };
    })(this)()).pipe($((function(_this) {
      return function(tags_and_chrs, send) {
        var e, idx;
        return send(((function() {
          var _i, _len, _results;
          _results = [];
          for (idx = _i = 0, _len = tags_and_chrs.length; _i < _len; idx = ++_i) {
            e = tags_and_chrs[idx];
            _results.push(idx % 2 ? e.join('') : e);
          }
          return _results;
        })()).join(''));
      };
    })(this))).pipe((function(_this) {
      return function() {
        return $(function(html, send) {

          /* Build galley HTML structure */

          /* We're receiving the HTML of a text batch that is divided into block elements;
          typically those are headers, paragraphs, code blocks and so on. We wrap all of those into a
          common `<div>` with a unique ID so jQuery can build an HTML fragment with a single root element
          and we can easily refer back to this particular batch. Furthermore, we wrap all the contents of
          top level blocks into `<span>`s with class `.line-counter` that we can then use to find the
          enclosing rectangles of each line in each block.
           */
          var batch, batch_id, batch_info, blocks;
          matter['batch-idx'] += +1;
          batch_id = "mkts-galley-batch-" + matter['batch-idx'];
          batch = jQuery(("<div id='" + batch_id + "' class='mkts-galley-batch'>") + html + "</div>");
          blocks = batch.children();
          blocks.wrapInner("<span class='line-counter'></span>");
          batch_info = {
            '~isa': 'MKTS/LINESETTER/batch-info',
            '%batch': batch,
            '%blocks': blocks,
            'batch-id': batch_id
          };
          return send(batch_info);
        });
      };
    })(this)()).pipe((function(_this) {
      return function() {
        return $(function(batch_info, send) {
          var batch, batch_id, block, block_idx, block_info, block_infos, blocks, client_rectangle, client_rectangles, height, height_px, left, line_count, line_counter, line_counters, top, width, zleft, ztop, _i, _j, _len, _ref1;
          batch = batch_info['%batch'];
          blocks = batch_info['%blocks'];
          batch_id = batch_info['batch-id'];
          block_infos = [];
          line_counters = blocks.find('.line-counter');
          gcolumn.append(batch);
          debug('©4QfDG', "typesetting " + blocks.length + " blocks into galley...");
          for (block_idx = _i = 0, _ref1 = blocks.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; block_idx = 0 <= _ref1 ? ++_i : --_i) {
            block = blocks.eq(block_idx);
            line_counter = line_counters.eq(block_idx);
            client_rectangles = (line_counter.get(0)).getClientRects();
            line_count = client_rectangles.length;
            height_px = BD.get_rectangle(block, 'height');
            block_info = {
              '~isa': 'MKTS/LINESETTER/block-info',
              '%block': block,
              'line-count': line_count,
              'height.px': height_px
            };
            block_infos.push(block_info);
            if (mark_lines) {
              for (_j = 0, _len = client_rectangles.length; _j < _len; _j++) {
                client_rectangle = client_rectangles[_j];
                left = client_rectangle.left, top = client_rectangle.top, width = client_rectangle.width, height = client_rectangle.height;
                zleft = left - gcolumn_left;
                ztop = top - gcolumn_top;
                batch.append(jQuery("<div style='position:absolute;left:" + zleft + "px;top:" + ztop + "px;width:" + width + "px;height:" + height + "px;outline:1px solid rgba(255,0,0,0.25);'></div>"));
              }
            }
          }
          debug('©4QfDG', "...done");
          return send(block_infos);
        });
      };
    })(this)()).pipe((function(_this) {
      return function() {
        return $(function(block_infos, send, end) {
          var block, block_height_px, block_idx, block_info, caret, column, column_count, columns, current_line_count, height_nmm, height_rmm, page, pages, target_height_px, _i, _len;
          if (block_infos != null) {
            MKTS.VIEW.show_pages();
            caret = matter.caret;
            pages = jQuery('artboard.pages page');
            page = null;
            columns = null;
            column_count = null;
            column = null;
            target_height_px = null;
            current_line_count = null;

            /* Move to target */
            for (block_idx = _i = 0, _len = block_infos.length; _i < _len; block_idx = ++_i) {
              block_info = block_infos[block_idx];
              if (page == null) {
                page = pages.eq(caret['page-nr'] - 1);
              }
              if (columns == null) {
                columns = page.find('column');
              }
              if (column_count == null) {
                column_count = columns.length;
              }
              if (column_count < 1) {
                warn("skipped " + (block_infos.length - block_idx) + " blocks because of missing columns");
                break;
              }
              if (column == null) {
                column = columns.eq(caret['column-nr'] - 1);
              }
              if (current_line_count == null) {
                current_line_count = 0;
              }
              if (target_height_px == null) {
                target_height_px = BD.get_rectangle(column, 'height');
              }
              height_nmm = current_line_count * 5;
              height_rmm = mm_from_rpx(caret['y.px']);
              current_line_count += block_info['line-count'];
              block = block_info['%block'];
              block_height_px = block_info['height.px'];
              column.append(block);
              caret['y.px'] += block_height_px;
              if (caret['y.px'] < target_height_px) {
                continue;
              }
              caret['column-nr'] += +1;
              caret['y.px'] = 0;
              column = null;
              current_line_count = null;
              urge('©08Nsv', MKTS.CARET.as_url(app, matter));
              if (caret['column-nr'] > column_count) {
                page = null;
                columns = null;
                column_count = null;
                target_height_px = null;
                caret['column-nr'] = 1;
                caret['page-nr'] += +1;
                caret['y.px'] = 0;
                help('©l4U89', MKTS.CARET.as_url(app, matter));
              }
            }
          }
          if (end != null) {
            return end();
          }
        });
      };
    })(this)());
    input.write(md);
    return input.end();
  };

}).call(this);
