// Generated by CoffeeScript 1.9.1
(function() {
  var $, $async, BD, CND, COLUMN, D, HOTMETAL, MKTS, XCSS, after, alert, app, badge, debug, document, echo, glyph_replacements, help, info, jQuery, later, log, mm_from_npx, mm_from_rpx, now, npx_from_mm, rpr, rpx_from_mm, sleep, step, suspend, urge, warn, whisper, window, ƒ;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/LINESETTER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  later = setImmediate;

  sleep = suspend.sleep;

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  HOTMETAL = D.HOTMETAL;

  XCSS = require('./XCSS');

  BD = require('./BLAIDDDRWG');

  glyph_replacements = require('./glyph-replacements');


  /* https://github.com/meryn/performance-now */

  now = require('performance-now');


  /* The module-globals become available when `demo` is called with `app` argument */

  jQuery = null;

  MKTS = null;

  window = null;

  document = null;

  app = null;

  mm_from_rpx = function(d) {
    return MKTS.GAUGE.mm_from_rpx(app, d);
  };

  mm_from_npx = function(d) {
    return MKTS.GAUGE.mm_from_npx(app, d);
  };

  rpx_from_mm = function(d) {
    return MKTS.GAUGE.rpx_from_mm(app, d);
  };

  npx_from_mm = function(d) {
    return MKTS.GAUGE.npx_from_mm(app, d);
  };

  ƒ = function(x, precision) {
    if (precision == null) {
      precision = 2;
    }
    return x.toFixed(precision);
  };

  this._get_slugs_container = function(gcolumn) {
    var R;
    R = jQuery('container');
    if (R.length === 0) {
      R = jQuery("<container style='display:block;width:100%;height:30mm;outline:1px solid red'></container>");
      gcolumn.append(R);
    }
    return R;
  };

  this.get_column_linecounts = function(strategy, line_count, column_count) {

    /* thx to http://stackoverflow.com/a/1244369/256361 */
    var R, col, i, ref;
    R = [];
    switch (strategy) {
      case 'even':
        for (col = i = 1, ref = column_count; 1 <= ref ? i <= ref : i >= ref; col = 1 <= ref ? ++i : --i) {
          R.push(Math.floor((line_count + column_count - col) / column_count));
        }
        break;
      default:
        throw new Error("unknown strategy " + (rpr(strategy)));
    }
    return R;
  };

  COLUMN = {};

  COLUMN.new_column = function(substrate, selector) {
    var R, elements, i, idx, lines, ref;
    R = {
      '~isa': 'LINESETTER/column',
      '%self': substrate,
      'lines': lines = [],
      'length': 0
    };
    if (selector != null) {
      elements = substrate.find(selector);
      for (idx = i = 0, ref = elements.length; 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
        lines.push(elements.eq(idx));
      }
      R['length'] = elements.length;
    }
    return R;
  };

  COLUMN.push = function(me, line) {
    if (CND.isa_text(line)) {
      line = jQuery(line);
    }
    me['lines'].push(line);
    me['%self'].append(line);
    me['length'] = me['lines'].length;
    return me;
  };

  COLUMN.pop = function(me) {
    var R;
    if (me['length'] < 1) {
      throw new Error("unable to pop from empty list");
    }
    R = me['lines'].pop();
    R.detach();
    me['length'] = me['lines'].length;
    return R;
  };

  COLUMN.insert = function(me, line, idx) {
    if (CND.isa_text(line)) {
      line = jQuery(line);
    }
    if (idx != null) {
      me['lines'].splice(idx, 0, line);
      me['%self'][idx].before(line);
    } else {
      me['lines'].unshift(line);
      me['%self'].prepend(line);
    }
    me['length'] = me['lines'].length;
    return me;
  };

  COLUMN.pull = function(me) {
    var R;
    R = me['%lines'].shift();
    R.detach();
    me['length'] = me['lines'].length;
    return R;
  };

  COLUMN.pop_over = function(me, other, count, handler) {
    var _, arity, i, length, ref;
    if (count == null) {
      count = 1;
    }
    if (handler == null) {
      handler = null;
    }
    switch (arity = arguments.length) {
      case 2:
      case 4:
        null;
        break;
      case 3:
        if (CND.isa_function(count)) {
          handler = count;
          count = 1;
        }
        break;
      default:
        throw new Error("expected between 2 and 4 arguments, got " + arity);
    }
    if (handler != null) {
      return this.pop_over_async(me, other, count(handler));
    }
    if ((length = me['length']) < me['length']) {
      throw new Error("unable to divide with count " + count + " and length " + length);
    }
    if (!CND.isa(other, 'LINESETTER/column')) {
      other = this.new_column(substrate);
    }
    for (_ = i = 1, ref = count; 1 <= ref ? i <= ref : i >= ref; _ = 1 <= ref ? ++i : --i) {
      this.insert(other, this.pop(me));
    }
    return [me, other];
  };

  COLUMN.pop_over_async = function(me, other, count, handler) {
    var length;
    if ((length = me['length']) < me['length']) {
      throw new Error("unable to divide with count " + count + " and length " + length);
    }
    if (!CND.isa(other, 'LINESETTER/column')) {
      other = this.new_column(substrate);
    }
    return step((function(_this) {
      return function*(resume) {
        var _, i, line, ref;
        for (_ = i = 1, ref = count; 1 <= ref ? i <= ref : i >= ref; _ = 1 <= ref ? ++i : --i) {
          line = _this.pop(me);
          (yield after(0.001, resume));
          _this.insert(other, line);
        }
        return handler(null, [me, other]);
      };
    })(this));
  };

  this.try_slug = (function(_this) {
    return function(container, block_hotml, line_nr, start_idx, stop_idx) {
      var block_tag, client_rectangle, client_rectangles, client_width, container_width, excess, line_count, line_counter, slug_hotml, slug_html, slug_jq;
      slug_hotml = HOTMETAL.slice(block_hotml, start_idx, stop_idx + 1);
      block_tag = slug_hotml[0][0][0];
      HOTMETAL.TAG.set(block_tag, 'line-nr', line_nr);
      HOTMETAL.TAG.add_class(block_tag, 'slug');
      if (line_nr === 1) {
        HOTMETAL.TAG.add_class(block_tag, 'first');
      } else {
        HOTMETAL.TAG.add_class(block_tag, 'middle');
      }
      slug_html = HOTMETAL.as_html(slug_hotml);
      slug_jq = jQuery(slug_html);
      line_counter = slug_jq.children()[0];
      container.append(slug_jq);
      client_rectangles = line_counter.getClientRects();
      container_width = container.width();
      client_rectangle = client_rectangles[0];
      client_width = client_rectangle['right'] - container.offset()['left'];
      excess = Math.max(0, Math.floor(client_width - container_width));

      /* TAINT arbitrary precision limit */
      if (excess < 3) {
        excess = 0;
      }
      if (excess > 0) {
        warn(slug_html);
        warn("exceeding container by " + (excess.toFixed(1)) + "px");
      }
      line_count = client_rectangles.length;
      return [slug_hotml, slug_html, line_count, excess];
    };
  })(this);

  this.$get_slugs = function(gcolumn) {
    var container;
    container = this._get_slugs_container(gcolumn);
    return $((function(_this) {
      return function(block_hotml, send) {
        var excess, excesses, good_slug_html, html_lines, is_finished, last_line_block_tag, last_line_hotml, last_line_html, last_start_idx, line_count, line_nr, new_class, ref, slice_hotml, slices, slug_html, start_idx, stop_idx, trial_count;
        start_idx = 0;
        stop_idx = 0;
        trial_count = 0;
        last_start_idx = block_hotml.length - 1;
        html_lines = [];
        slices = [];
        excesses = [];
        slug_html = null;
        good_slug_html = null;
        is_finished = false;
        line_nr = 0;
        while (!is_finished) {
          trial_count += +1;
          good_slug_html = slug_html;
          line_nr = html_lines.length + 1;
          ref = _this.try_slug(container, block_hotml, line_nr, start_idx, stop_idx), slice_hotml = ref[0], slug_html = ref[1], line_count = ref[2], excess = ref[3];
          if (stop_idx >= last_start_idx) {
            excesses.push(excess);
            slices.push(slice_hotml);
            html_lines.push(slug_html);
            is_finished = true;
            continue;
          }
          if (line_count > 1) {
            if (trial_count === 1) {
              throw new Error("not yet implemented");
            }
            excesses.push(excess);
            slices.push(slice_hotml);
            html_lines.push(good_slug_html);
            start_idx = stop_idx;
            stop_idx = start_idx - 1;
          }
          stop_idx += +1;
          if (start_idx >= last_start_idx) {
            throw new Error("not yet implemented");
          }
        }
        excess = excesses[excesses.length - 1];
        new_class = slices.length === 1 ? 'single' : 'last';
        last_line_hotml = slices[slices.length - 1];
        last_line_block_tag = last_line_hotml[0][0][0];
        HOTMETAL.TAG.remove_class(last_line_block_tag, 'middle');
        HOTMETAL.TAG.remove_class(last_line_block_tag, 'first');
        HOTMETAL.TAG.add_class(last_line_block_tag, new_class);
        if (excess > 0) {
          HOTMETAL.TAG.add_class(last_line_block_tag, 'excess');
        }
        last_line_html = HOTMETAL.as_html(last_line_hotml);
        html_lines[html_lines.length - 1] = last_line_html;
        container.empty();
        send(html_lines);
        return help(((trial_count / html_lines.length).toFixed(2)) + " trials per line");
      };
    })(this));
  };

  this.$xxx = function() {
    var line_count, lines, target_column, target_column_idx, target_columns;
    target_columns = jQuery('page column');
    target_column_idx = 0;
    target_column = target_columns.eq(target_column_idx);
    line_count = 0;
    lines = [];
    return $((function(_this) {
      return function(html_lines, send, end) {
        var bottom_mm, bottom_px, column_height_mm, column_rectangle, delta_y_px, epsilon_mm, height_mm, height_px, html_line, i, is_off, len, line, line_idx, overshoot_mm, rectangle, top_mm, top_px, width_mm, width_px;
        if (html_lines != null) {

          /* TAINT no need to recompute on each paragraph */
          column_rectangle = BD.get_rectangle(target_column);
          delta_y_px = column_rectangle['top'];
          column_height_mm = mm_from_npx(column_rectangle['height']);

          /* TAINT arbitrary precision */
          epsilon_mm = 0.5;
          for (line_idx = i = 0, len = html_lines.length; i < len; line_idx = ++i) {
            html_line = html_lines[line_idx];
            line_count += +1;
            line = jQuery(html_line);
            lines.push(line);
            target_column.append(line);
            rectangle = BD.get_rectangle(line);
            width_px = rectangle['width'];
            height_px = rectangle['height'];
            top_px = rectangle['top'] - delta_y_px;
            bottom_px = rectangle['bottom'] - delta_y_px;
            width_mm = mm_from_npx(width_px);
            height_mm = mm_from_npx(height_px);
            top_mm = mm_from_npx(top_px);
            bottom_mm = mm_from_npx(bottom_px);
            overshoot_mm = bottom_mm - column_height_mm;
            is_off = overshoot_mm >= epsilon_mm;
            if (is_off) {

              /* TAINT must detect when page full */
              target_column_idx += +1;
              target_column = target_columns.eq(target_column_idx);
              line.detach();
              target_column.append(line);
            }
            debug('©bPew4', line_idx, ƒ(bottom_mm, 1), ƒ(column_height_mm, 1), ƒ(overshoot_mm, 1), is_off, line.text().slice(0, 21));
          }
          send(html_lines);
        }
        if (end != null) {
          return end();
        }
      };
    })(this));
  };

  this.demo = function(app_, md, settings, handler) {
    var XXX_t0, XXX_times, arity, as_html, format, gcolumn, gcolumn_left, gcolumn_offset, gcolumn_top, input, mark_chrs, mark_lines, matter, ref, zoomer;
    switch (arity = arguments.length) {
      case 3:
        handler = settings;
        settings = {};
        break;
      case 4:
        null;
        break;
      default:
        throw new Error(" expected 3 or 4 arguments, got " + arity);
    }
    switch (format = (ref = settings['format']) != null ? ref : 'md') {
      case 'md':
        as_html = D.MD.$as_html();
        break;
      case 'html':
        as_html = D.$pass_through();
        break;
      default:
        return handler(new Error("unknown format " + (rpr(format))));
    }
    app = app_;
    matter = app['matter'];
    jQuery = app['jQuery'];
    MKTS = app['MKTS'];
    window = app['window'];
    document = window['document'];
    BD = window['BD'];
    gcolumn = (jQuery('galley column')).eq(0);
    gcolumn_offset = gcolumn.offset();
    gcolumn_left = gcolumn_offset['left'];
    gcolumn_top = gcolumn_offset['top'];
    zoomer = jQuery('zoomer');
    input = D.create_throughstream();
    mark_chrs = true;
    mark_lines = false;
    XXX_t0 = +new Date();
    XXX_times = [];
    input.pipe(as_html).pipe($((function(_this) {
      return function(html, send) {
        XXX_times.push(["html from markdown", new Date() - XXX_t0]);
        send(HOTMETAL.HTML.parse(html));
        return XXX_times.push(["html parsed into hotml", new Date() - XXX_t0]);
      };
    })(this))).pipe($((function(_this) {
      return function(hotml, send) {

        /* split document into blocks */
        var block_hotml, i, len, ref1, results;
        ref1 = HOTMETAL.slice_toplevel_tags(hotml);
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          block_hotml = ref1[i];
          results.push(send(block_hotml));
        }
        return results;
      };
    })(this))).pipe($async((function(_this) {
      return function(data, done) {
        return later(function() {
          return done(data);
        });
      };
    })(this))).pipe($((function(_this) {
      return function(block_hotml, send) {

        /* Wrap block contents in `line-counter`; method analoguous to `jQuery.wrapInner` */
        block_hotml[0][0].push(['line-counter', {}]);
        block_hotml[block_hotml.length - 1][2].unshift(['line-counter']);
        return send(block_hotml);
      };
    })(this))).pipe(this.$get_slugs(gcolumn)).pipe(this.$xxx()).pipe(D.$on_end(function() {

      /* !!! */
      var description, dt, i, len, ref1;
      XXX_times.push(["finished", new Date() - XXX_t0]);
      for (i = 0, len = XXX_times.length; i < len; i++) {
        ref1 = XXX_times[i], description = ref1[0], dt = ref1[1];
        debug('©1enOB', description, (dt / 1000).toFixed(3));
      }
      return handler();
    }));
    input.write(md);
    return input.end();
  };

  this._demo_pop_over = function() {
    var columns, i, idx, target_columns;
    target_columns = jQuery('page column');
    columns = [];
    for (idx = i = 0; i <= 2; idx = ++i) {
      columns.push(COLUMN.new_column(target_columns.eq(idx), '.slug'));
    }
    debug('©1rmzT', columns[0].length, columns[1].length, columns[2].length);
    COLUMN.pop_over(columns[0], columns[1], 1);
    return debug('©1rmzT', columns[0].length, columns[1].length);
  };

  this._demo_pop_over_async = function() {
    var column, column_idx, column_linecounts, columns, columns_per_page, i, line_count, ref, target_columns;
    target_columns = jQuery('page column');
    columns = [];

    /* TAINT arbitrary constant */
    columns_per_page = 3;
    line_count = 0;
    for (column_idx = i = 0, ref = columns_per_page; 0 <= ref ? i < ref : i > ref; column_idx = 0 <= ref ? ++i : --i) {
      column = COLUMN.new_column(target_columns.eq(column_idx), '.slug');
      line_count += column['length'];
      columns.push(column);
    }
    column_linecounts = this.get_column_linecounts('even', line_count, columns_per_page);
    debug('©rnC7h', column_linecounts);
    return step((function(_this) {
      return function*(resume) {
        var j, ref1, results;
        results = [];
        for (column_idx = j = 0, ref1 = columns_per_page; 0 <= ref1 ? j < ref1 : j > ref1; column_idx = 0 <= ref1 ? ++j : --j) {
          column = columns[column_idx];
          results.push((yield* (function*() {
            var results1;
            results1 = [];
            while (column['length'] > column_linecounts[column_idx]) {

              /* TAINT invalid last column idx */
              results1.push((yield COLUMN.pop_over_async(columns[column_idx], columns[column_idx + 1], 1, resume)));
            }
            return results1;
          })()));
        }
        return results;
      };
    })(this));
  };

}).call(this);
