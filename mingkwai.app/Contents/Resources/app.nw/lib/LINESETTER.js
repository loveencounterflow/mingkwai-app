// Generated by CoffeeScript 1.8.0
(function() {
  var $collect_tags, $distribute_lines, $hyphenate, $join_text_nodes, $split_texts, CND, D2, Htmlparser, LineBreaker, TEACUP, after, alert, badge, debug, echo, help, hyphenate, info, log, new_html_parser, njs_fs, njs_path, partition_text, remit, render_close_tag, render_open_tag, rpr, sleep, step, suspend, urge, warn, whisper,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('coffeenode-trm');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/linesetter';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  sleep = suspend.sleep;

  D2 = require('pipedreams2');

  remit = D2.remit.bind(D2);

  Htmlparser = (require('htmlparser2')).Parser;

  TEACUP = require('coffeenode-teacup');


  /* https://github.com/devongovett/linebreak */

  LineBreaker = require('linebreak');


  /* https://github.com/bramstein/hypher */

  hyphenate = null;

  (function() {
    var _HYPHER, _Hypher, _hypher_english;
    _Hypher = require('hypher');
    _hypher_english = require('hyphenation.en-us');
    _HYPHER = new _Hypher(_hypher_english);
    return hyphenate = _HYPHER.hyphenateText.bind(_HYPHER);
  })();

  partition_text = function(text) {
    var R, breakpoint, line_breaker;
    line_breaker = new LineBreaker(text);
    breakpoint = null;
    R = [];
    while (breakpoint = line_breaker.nextBreak()) {
      R.push(text.slice(0, breakpoint.position));
    }
    return R;
  };

  render_open_tag = function(name, attributes) {
    return (TEACUP.render((function(_this) {
      return function() {
        return TEACUP.TAG(name, attributes);
      };
    })(this))).replace(/<\/[^>]+>$/, '');
  };

  render_close_tag = function(name) {
    return "</" + name + ">";
  };

  new_html_parser = function(settings, stream) {
    var handlers, lone_tags;
    lone_tags = "area base br col command embed hr img input keygen link meta param\nsource track wbr".split(/\s+/);
    handlers = {
      onopentag: function(name, attributes) {
        if (__indexOf.call(lone_tags, name) >= 0) {
          return stream.write(['lone-tag', [name, attributes]]);
        } else {
          return stream.write(['open-tag', [name, attributes]]);
        }
      },
      onclosetag: function(name) {
        if (__indexOf.call(lone_tags, name) < 0) {
          return stream.write(['close-tag', name]);
        }
      },
      ontext: function(text) {
        return stream.write(['text', text]);
      },
      onend: function() {
        stream.write(['end']);
        return stream.end();
      },
      onerror: function(error) {
        throw error;
      }
    };
    return new Htmlparser(handlers, settings);
  };

  $distribute_lines = function(test_line, send_line, done) {
    var buffer, last_idx, last_opener, overflows;
    last_opener = '';
    buffer = [];
    last_idx = 0;
    overflows = false;
    return remit((function(_this) {
      return function(event, send, end) {
        var chr_count, closer, data, idx, name, opener, part, parts, pending_tags, prefix, probe, probe_part, sub_idx, sub_part, type, _i, _len;
        type = event[0], data = event[1], pending_tags = event[2];
        switch (type) {
          case 'end':
            send(event);
            break;
          case 'text-parts':
            closer = ((function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = pending_tags.length; _i < _len; _i++) {
                name = pending_tags[_i];
                _results.push(render_close_tag(name));
              }
              return _results;
            })()).join('');
            prefix = last_opener.replace(/\xad$/, '-');
            idx = -1;
            parts = data;
            while (true) {
              idx += +1;
              part = parts[idx];
              if (part == null) {
                break;
              }

              /* TAINT must escape HTML-sensitive characters; NCRs? */
              opener = prefix + part;
              probe_part = part.replace(/\xad$/, '-');
              probe_part = probe_part.replace(/\x20+$/, '');
              probe = prefix + probe_part + closer;
              overflows = test_line(probe);
              debug('©xlcUa', parts, idx);
              if (overflows) {
                warn(buffer[buffer.length - 1]);
                chr_count = parts[idx - 1].length;
                parts.splice(0, idx);
                for (sub_idx = _i = 0, _len = parts.length; _i < _len; sub_idx = ++_i) {
                  sub_part = parts[sub_idx];
                  parts[sub_idx] = sub_part.slice(chr_count);
                }
                idx = -1;

                /* TAINT need not buffer all candidates */
                send_line(buffer[buffer.length - 2][6]);
              }
              buffer.push([opener, closer, part, parts, idx, overflows, probe]);
              last_opener = opener;
            }
            break;
          case 'open-tag':
            opener = last_opener + render_open_tag.apply(null, data);
            closer = ((function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pending_tags.length; _j < _len1; _j++) {
                name = pending_tags[_j];
                _results.push(render_close_tag(name));
              }
              return _results;
            })()).join('');
            probe = opener + closer;
            overflows = test_line(probe);
            if (overflows) {
              warn(buffer[buffer.length - 1]);
            }
            buffer.push([opener, closer, null, null, null, overflows, probe]);
            last_opener = opener;
            break;
          case 'close-tag':
            opener = last_opener + render_close_tag(data);
            closer = ((function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = pending_tags.length; _j < _len1; _j++) {
                name = pending_tags[_j];
                _results.push(render_close_tag(name));
              }
              return _results;
            })()).join('');
            probe = opener + closer;
            last_opener = opener;
            break;
          default:
            warn("ignoring " + type);
        }
        if (end != null) {
          send_line(null);
          done();
          return end();
        }
      };
    })(this));
  };

  this.set_lines = function(source, test_line, send_line, done) {
    var html_parser, settings, stream;
    settings = {
      decodeEntities: true
    };
    stream = D2.create_throughstream();
    html_parser = new_html_parser(settings, stream);
    html_parser.write(source);
    html_parser.end();
    return stream.pipe($join_text_nodes()).pipe($hyphenate()).pipe($collect_tags()).pipe(D2.$show());
  };

  $join_text_nodes = function() {

    /* Make sure that all the text content of a given range of the source is represented by a single text
    node; in the browser, this is done using
    [node.normalize()](https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize).
     */
    var buffer;
    buffer = [];
    return remit(function(event, send, end) {
      var tail, type;
      if (event != null) {
        type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
        if (type === 'text') {
          buffer.push(tail[0]);
        } else {
          if (buffer.length > 0) {
            send(['text', buffer.join('')]);
          }
          buffer.length = 0;
          send(event);
        }
      }
      if (end != null) {
        if (buffer.length > 0) {
          send(['text', buffer.join('')]);
        }
        return end();
      }
    });
  };

  $hyphenate = function() {

    /* TAINT must allow language settings */
    return remit(function(event, send) {
      var tail, type;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'text') {
        return send(['text', hyphenate(tail[0])]);
      } else {
        return send(event);
      }
    });
  };

  $collect_tags = function() {
    var pending_tag_buffer;
    pending_tag_buffer = [];
    return remit(function(event, send) {
      var tail, type;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'open-tag') {
        pending_tag_buffer.unshift(tail[0][0]);
      } else if (type === 'close-tag') {
        pending_tag_buffer.shift();
      }
      if (type !== 'end') {
        event.push(pending_tag_buffer.slice(0));
      }
      return send(event);
    });
  };

  $split_texts = function() {
    return remit(function(event, send) {
      var parts, tail, text, type;
      type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
      if (type === 'text') {
        text = tail[0];
        parts = partition_text(text);
        return send(['text-parts', parts, tail[1]]);
      } else {
        return send(event);
      }
    });
  };


  /*
  
  foo <b><i>is it</i> really</b> baz
  
  'foo'
  'foo', ' '
  'foo', ' ', <b><i>, 'is', ⬇, ⬇
  'foo', ' ', <b><i>, 'is', ' ', ⬇, ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', 'really', ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', 'really', ⬇, ' '
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', 'really', ⬇, ' ', 'baz'
  
  'foo'
  'foo '
  'foo <b><i>is</i></b>'
  'foo <b><i>is </i></b>'
  'foo <b><i>is it</i></b>'
  'foo <b><i>is it</i> </b>'
  'foo <b><i>is it</i> really</b>'
  'foo <b><i>is it</i> really</b> '
  'foo <b><i>is it</i> really</b> baz'
   */

}).call(this);
