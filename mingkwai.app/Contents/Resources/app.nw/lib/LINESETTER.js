// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, D, HOTMETAL, XCSS, after, alert, badge, debug, echo, help, info, log, rpr, sleep, step, suspend, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/LINESETTER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  sleep = suspend.sleep;

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  HOTMETAL = D.HOTMETAL;

  XCSS = require('./XCSS');

  this.demo = function(app, md, settings, handler) {
    var MKTS, arity, block_idx, document, gcolumn, gcolumn_left, gcolumn_offset, gcolumn_top, input, jQuery, line_idx, live, mark_chrs, mm_from_px, t0, t1_a, window, zoomer, ƒ;
    switch (arity = arguments.length) {
      case 3:
        handler = settings;
        settings = {};
        break;
      case 4:
        null;
        break;
      default:
        throw new Error(" expected 3 or 4 arguments, got " + arity);
    }
    jQuery = app['jQuery'];
    MKTS = app['MKTS'];
    window = app['window'];
    document = window['document'];
    gcolumn = (jQuery('galley column')).eq(0);
    gcolumn_offset = gcolumn.offset();
    gcolumn_left = gcolumn_offset['left'];
    gcolumn_top = gcolumn_offset['top'];
    zoomer = jQuery('zoomer');
    mm_from_px = function(px) {
      return px * app['mm-per-px'];
    };
    ƒ = function(x, precision) {
      if (precision == null) {
        precision = 0;
      }
      return x.toFixed(precision);
    };
    input = D.create_throughstream();
    live = true;
    live = false;
    t0 = +new Date();
    t1_a = null;
    block_idx = -1;
    line_idx = -1;
    mark_chrs = true;
    mark_chrs = false;
    t0 = +new Date();
    input.pipe(D.MD.$as_html()).pipe(D.HTML.$parse({
      disperse: true,
      hyphenation: true,
      whitespace: false,
      chrs: false
    })).pipe($(function(data, send) {
      debug('©x-1');
      return send(data);
    })).pipe(D.HTML.$slice_toplevel_tags()).pipe($(function(data, send) {
      debug('©x-2');
      return send(data);
    })).pipe((function(_this) {
      return function() {
        return $(function(block_hotml, send, end) {
          var block, block_chr_idx, block_html, bottom, chr_idx, entry, height, last_left, last_top, left, left_0, line_start_idx, line_stop_idx, lines, node, node_dom, node_idx, range, rectangles, right, t1, text, text_nodes, top, top_0, width, zleft, ztop, _i, _j, _len, _ref, _ref1;
          t1 = +new Date();
          debug('©x-3', ƒ(t1 - t0));
          if (block_hotml != null) {
            block_idx += +1;
            block_chr_idx = 0;
            lines = [];
            line_start_idx = 0;
            block_html = HOTMETAL.as_html(block_hotml, false);
            block = jQuery(block_html);
            gcolumn.append(block);
            text_nodes = block.text_nodes();
            last_left = null;
            last_top = null;
            for (node_idx = _i = 0, _ref = text_nodes.length; 0 <= _ref ? _i < _ref : _i > _ref; node_idx = 0 <= _ref ? ++_i : --_i) {
              node = text_nodes.eq(node_idx);
              node_dom = node.get(0);
              range = document.createRange();
              chr_idx = 0;
              text = node.text();
              left_0 = null;
              top_0 = null;
              while (chr_idx < text.length) {
                range.setStart(node_dom, chr_idx);
                chr_idx += (text.codePointAt(chr_idx)) > 0xffff ? +2 : +1;
                range.setEnd(node_dom, chr_idx);
                block_chr_idx += +1;
                _ref1 = range.getBoundingClientRect(), bottom = _ref1.bottom, height = _ref1.height, left = _ref1.left, right = _ref1.right, top = _ref1.top, width = _ref1.width;
                rectangles = range.getClientRects();

                /* Collapsing characters (combining diacritics, trailing whitespace) has a position and
                a size of zero in both dimensions; we always treat such characters as belonging to the
                current line:
                 */
                if (((left === top && top === width) && width === 0)) {
                  continue;
                }

                /* If `left_0` isn't yet set, make the current dimension the reference point: */
                if (left_0 == null) {
                  line_idx += +1;
                  left_0 = left;
                  top_0 = top;
                }

                /* Naive guess: when `left` has decreased and `top` has increased, a new line has
                started. NB this definitely won't work with right-to-left and bottom-to-top directions.
                 */
                if (last_left != null) {
                  if (left < last_left && top > last_top) {
                    lines.push([line_start_idx, block_chr_idx - 1]);
                    line_start_idx = block_chr_idx - 1;
                  }
                }
                last_left = left;
                last_top = top;
                if (mark_chrs) {
                  zleft = left - gcolumn_left;
                  ztop = top - gcolumn_top;
                  gcolumn.append(jQuery("<div style='position:absolute;left:" + zleft + "px;top:" + ztop + "px;width:" + width + "px;height:" + height + "px;outline:1px solid rgba(255,0,0,0.25);'></div>"));
                }
              }
            }
            if (block_chr_idx > line_start_idx) {
              lines.push([line_start_idx, block_chr_idx]);
            }
            for (line_idx = _j = 0, _len = lines.length; _j < _len; line_idx = ++_j) {
              entry = lines[line_idx];
              line_start_idx = entry[0], line_stop_idx = entry[1];
            }
          }
          if (end != null) {
            return window.lines = lines;
          }
        });
      };
    })(this)());
    input.write(md);
    return input.end();
  };

}).call(this);
