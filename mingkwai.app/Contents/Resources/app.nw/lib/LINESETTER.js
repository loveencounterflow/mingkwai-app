// Generated by CoffeeScript 1.9.1
(function() {
  var $, $async, BD, CND, COLUMN, D, HOTMETAL, MKTS, XCSS, after, alert, app, badge, debug, document, echo, glyph_replacements, help, info, jQuery, later, log, mm_from_npx, mm_from_rpx, now, npx_from_mm, rpr, rpx_from_mm, sleep, step, suspend, urge, warn, whisper, window, ƒ;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/LINESETTER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  later = setImmediate;

  sleep = suspend.sleep;

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  HOTMETAL = D.HOTMETAL;

  XCSS = require('./XCSS');

  BD = require('./BLAIDDDRWG');

  glyph_replacements = require('./glyph-replacements');


  /* https://github.com/meryn/performance-now */

  now = require('performance-now');


  /* The module-globals become available when `demo` is called with `app` argument */

  jQuery = null;

  MKTS = null;

  window = null;

  document = null;

  app = null;

  mm_from_rpx = function(d) {
    return MKTS.GAUGE.mm_from_rpx(app, d);
  };

  mm_from_npx = function(d) {
    return MKTS.GAUGE.mm_from_npx(app, d);
  };

  rpx_from_mm = function(d) {
    return MKTS.GAUGE.rpx_from_mm(app, d);
  };

  npx_from_mm = function(d) {
    return MKTS.GAUGE.npx_from_mm(app, d);
  };

  ƒ = function(x, precision) {
    if (precision == null) {
      precision = 2;
    }
    return x.toFixed(precision);
  };

  this._get_slugs_container = function(gcolumn) {
    var R;
    R = jQuery('container');
    if (R.length === 0) {
      R = jQuery("<container style='display:block;width:100%;height:30mm;outline:1px solid red'></container>");
      gcolumn.append(R);
    }
    return R;
  };

  this.get_column_linecounts = function(strategy, line_count, column_count) {

    /* thx to http://stackoverflow.com/a/1244369/256361 */
    var R, col, i, ref;
    R = [];
    switch (strategy) {
      case 'even':
        for (col = i = 1, ref = column_count; 1 <= ref ? i <= ref : i >= ref; col = 1 <= ref ? ++i : --i) {
          R.push(Math.floor((line_count + column_count - col) / column_count));
        }
        break;
      default:
        throw new Error("unknown strategy " + (rpr(strategy)));
    }
    return R;
  };

  COLUMN = {};

  COLUMN.new_column = function(substrate, selector) {
    var R, elements, i, idx, lines, ref;
    R = {
      '~isa': 'LINESETTER/column',
      '%self': substrate,
      'lines': lines = [],
      'length': 0
    };
    if (selector != null) {
      elements = substrate.find(selector);
      for (idx = i = 0, ref = elements.length; 0 <= ref ? i < ref : i > ref; idx = 0 <= ref ? ++i : --i) {
        lines.push(elements.eq(idx));
      }
      R['length'] = elements.length;
    }
    return R;
  };

  COLUMN.push = function(me, line) {
    if (CND.isa_text(line)) {
      line = jQuery(line);
    }
    me['lines'].push(line);
    me['%self'].append(line);
    me['length'] = me['lines'].length;
    return me;
  };

  COLUMN.pop = function(me) {
    var R;
    if (me['length'] < 1) {
      throw new Error("unable to pop from empty list");
    }
    R = me['lines'].pop();
    R.detach();
    me['length'] = me['lines'].length;
    return R;
  };

  COLUMN.insert = function(me, line, idx) {
    if (CND.isa_text(line)) {
      line = jQuery(line);
    }
    if (idx != null) {
      me['lines'].splice(idx, 0, line);
      me['%self'][idx].before(line);
    } else {
      me['lines'].unshift(line);
      me['%self'].prepend(line);
    }
    me['length'] = me['lines'].length;
    return me;
  };

  COLUMN.pull = function(me) {
    var R;
    R = me['%lines'].shift();
    R.detach();
    me['length'] = me['lines'].length;
    return R;
  };

  COLUMN.pop_over = function(me, other, count, handler) {
    var _, arity, i, length, ref;
    if (count == null) {
      count = 1;
    }
    if (handler == null) {
      handler = null;
    }
    switch (arity = arguments.length) {
      case 2:
      case 4:
        null;
        break;
      case 3:
        if (CND.isa_function(count)) {
          handler = count;
          count = 1;
        }
        break;
      default:
        throw new Error("expected between 2 and 4 arguments, got " + arity);
    }
    if (handler != null) {
      return this.pop_over_async(me, other, count(handler));
    }
    if ((length = me['length']) < me['length']) {
      throw new Error("unable to divide with count " + count + " and length " + length);
    }
    if (!CND.isa(other, 'LINESETTER/column')) {
      other = this.new_column(substrate);
    }
    for (_ = i = 1, ref = count; 1 <= ref ? i <= ref : i >= ref; _ = 1 <= ref ? ++i : --i) {
      this.insert(other, this.pop(me));
    }
    return [me, other];
  };

  COLUMN.pop_over_async = function(me, other, count, handler) {
    var length;
    if ((length = me['length']) < me['length']) {
      throw new Error("unable to divide with count " + count + " and length " + length);
    }
    if (!CND.isa(other, 'LINESETTER/column')) {
      other = this.new_column(substrate);
    }
    return step((function(_this) {
      return function*(resume) {
        var _, i, line, ref;
        for (_ = i = 1, ref = count; 1 <= ref ? i <= ref : i >= ref; _ = 1 <= ref ? ++i : --i) {
          line = _this.pop(me);
          (yield after(0.001, resume));
          _this.insert(other, line);
        }
        return handler(null, [me, other]);
      };
    })(this));
  };

  this.$add_column_formatting_signals = function() {
    var last_columns_setting;
    last_columns_setting = null;
    return $((function(_this) {
      return function(block_hotml, send) {

        /* TAINT inefficient because we convert to HTML and then to jQuery merely to see whether an XCSS
        selector matches the block element
         */
        var columns_setting, node;
        node = jQuery(HOTMETAL.as_html(block_hotml));
        if ((columns_setting = (XCSS.rules_from_node(app, node))['-mkts-columns']) != null) {
          if (columns_setting !== last_columns_setting) {
            send(['columns', columns_setting]);
          }
        }
        return send(['block', block_hotml]);
      };
    })(this));
  };

  this.try_slug = (function(_this) {
    return function(container, block_hotml, line_nr, start_idx, stop_idx) {
      var block_tag, client_rectangle, client_rectangles, client_width, container_width, excess, is_too_long, line_count, slug_hotml, slug_html, slug_jq, width_gauge;
      slug_hotml = HOTMETAL.slice(block_hotml, start_idx, stop_idx + 1);
      block_tag = slug_hotml[0][0][0];
      HOTMETAL.TAG.set(block_tag, 'line-nr', line_nr);
      HOTMETAL.TAG.add_class(block_tag, 'slug');
      if (line_nr === 1) {
        HOTMETAL.TAG.add_class(block_tag, 'first');
      } else {
        HOTMETAL.TAG.add_class(block_tag, 'middle');
      }
      slug_html = HOTMETAL.as_html(slug_hotml);
      slug_jq = jQuery(slug_html);
      width_gauge = slug_jq.children()[0];
      container.append(slug_jq);
      client_rectangles = width_gauge.getClientRects();
      container_width = container.width();
      client_rectangle = client_rectangles[0];
      client_width = client_rectangle['right'] - container.offset()['left'];
      excess = Math.max(0, Math.floor(client_width - container_width));

      /* TAINT arbitrary precision limit */
      if (excess < 3) {
        excess = 0;
      }
      is_too_long = excess > 0;
      line_count = client_rectangles.length;
      return [slug_hotml, slug_html, is_too_long, excess];
    };
  })(this);

  this.$get_slugs = function(gcolumn) {
    var container;
    container = this._get_slugs_container(gcolumn);
    return $((function(_this) {
      return function(block_hotml, send) {
        var excess, excesses, good_excess, good_slice_hotml, good_slug_html, html_lines, i, is_finished, is_too_long, last_line_block_tag, last_line_hotml, last_start_idx, len, line_nr, new_class, ref, slice_hotml, slices, slug_hotml, slug_html, slug_idx, start_idx, stop_idx, tag_hotml, trial_count;
        start_idx = 0;
        stop_idx = 0;
        trial_count = 0;
        last_start_idx = block_hotml.length - 1;
        html_lines = [];
        slices = [];
        excesses = [];
        slug_html = null;
        good_slug_html = null;
        good_slice_hotml = null;
        good_excess = null;
        is_finished = false;
        line_nr = 0;
        debug('©Wo0m7', HOTMETAL.as_html(block_hotml));
        while (!is_finished) {
          trial_count += +1;
          good_slug_html = slug_html;
          good_slice_hotml = slice_hotml;
          good_excess = excess;
          line_nr = html_lines.length + 1;

          /* --------------------- */

          /* TAINT arbitrary limit */
          if (trial_count > 25) {
            urge("#########################");
            warn("too many trials; aborting");
            urge("#########################");
            break;
          }
          if (line_nr > 25) {
            urge("#########################");
            warn("too many lines; aborting");
            urge("#########################");
            break;
          }

          /* --------------------- */
          ref = _this.try_slug(container, block_hotml, line_nr, start_idx, stop_idx), slice_hotml = ref[0], slug_html = ref[1], is_too_long = ref[2], excess = ref[3];
          urge('©uaDsn', start_idx, stop_idx, slug_html);
          if (stop_idx >= last_start_idx) {
            debug('©xeQQw', '(1)');
            excesses.push(excess);
            slices.push(slice_hotml);
            html_lines.push(slug_html);
            is_finished = true;
            continue;
          }
          if (is_too_long) {
            debug('©xeQQw', '(2)');
            warn(slug_html);
            warn("exceeding container by " + (excess.toFixed(1)) + "px");
            debug('©hBuvs', good_slug_html);
            if (trial_count === 1) {
              help('©wxSPj', slug_html);
              excesses.push(excess);
              slices.push(slice_hotml);
              html_lines.push(slug_html);
              debug('©TmJFr', excesses.length, slices.length, html_lines.length, excesses);
              start_idx = stop_idx + 1;
              stop_idx = start_idx - 1;
              trial_count = 0;
            } else {
              debug('©xeQQw', '(3)');
              excesses.push(good_excess);
              slices.push(good_slice_hotml);
              html_lines.push(good_slug_html);
              start_idx = stop_idx;
              stop_idx = start_idx - 1;
              trial_count = 0;
            }
          }
          debug('©xeQQw', '(4)');
          stop_idx += +1;
          if (start_idx >= last_start_idx) {
            throw new Error("not yet implemented (2)");
          }
        }
        new_class = slices.length === 1 ? 'single' : 'last';
        last_line_hotml = slices[slices.length - 1];
        last_line_block_tag = last_line_hotml[0][0][0];
        HOTMETAL.TAG.remove_class(last_line_block_tag, 'middle');
        HOTMETAL.TAG.remove_class(last_line_block_tag, 'first');
        HOTMETAL.TAG.add_class(last_line_block_tag, new_class);
        for (slug_idx = i = 0, len = slices.length; i < len; slug_idx = ++i) {
          slug_hotml = slices[slug_idx];
          tag_hotml = slug_hotml[0][0][0];
          excess = excesses[slug_idx];
          if (excess > 0) {
            HOTMETAL.TAG.add_class(tag_hotml, 'excess');
          }
          HOTMETAL.TAG.set(tag_hotml, 'excess', excess.toFixed(2));
          slug_html = HOTMETAL.as_html(slug_hotml);
          html_lines[slug_idx] = slug_html;
        }

        /* deactivate this to keep seeing lines in the galley */
        container.empty();
        send(html_lines);
        return help(((trial_count / html_lines.length).toFixed(2)) + " trials per line");
      };
    })(this));
  };

  this.$xxx = function() {
    var line_count, lines, target_column, target_column_idx, target_columns;
    target_columns = jQuery('page column');
    target_column_idx = 0;
    target_column = target_columns.eq(target_column_idx);
    line_count = 0;
    lines = [];
    return $((function(_this) {
      return function(html_lines, send, end) {
        var bottom_mm, bottom_px, column_height_mm, column_rectangle, delta_y_px, epsilon_mm, height_mm, height_px, html_line, i, is_off, len, line, line_idx, overshoot_mm, rectangle, top_mm, top_px, width_mm, width_px;
        if (html_lines != null) {

          /* TAINT no need to recompute on each paragraph */
          column_rectangle = BD.get_rectangle(target_column);
          delta_y_px = column_rectangle['top'];
          column_height_mm = mm_from_npx(column_rectangle['height']);

          /* TAINT arbitrary precision */
          epsilon_mm = 0.5;
          for (line_idx = i = 0, len = html_lines.length; i < len; line_idx = ++i) {
            html_line = html_lines[line_idx];
            line_count += +1;
            line = jQuery(html_line);
            lines.push(line);
            target_column.append(line);
            rectangle = BD.get_rectangle(line);
            width_px = rectangle['width'];
            height_px = rectangle['height'];
            top_px = rectangle['top'] - delta_y_px;
            bottom_px = rectangle['bottom'] - delta_y_px;
            width_mm = mm_from_npx(width_px);
            height_mm = mm_from_npx(height_px);
            top_mm = mm_from_npx(top_px);
            bottom_mm = mm_from_npx(bottom_px);
            overshoot_mm = bottom_mm - column_height_mm;
            is_off = overshoot_mm >= epsilon_mm;
            if (is_off) {

              /* TAINT must detect when page full */
              target_column_idx += +1;
              target_column = target_columns.eq(target_column_idx);
              line.detach();
              target_column.append(line);
            }
          }
          send(html_lines);
        }
        if (end != null) {
          return end();
        }
      };
    })(this));
  };

  this.demo = function(app_, md, settings, handler) {
    var XXX_t0, XXX_times, arity, as_html, format, gcolumn, gcolumn_left, gcolumn_offset, gcolumn_top, input, mark_chrs, mark_lines, matter, ref, zoomer;
    switch (arity = arguments.length) {
      case 3:
        handler = settings;
        settings = {};
        break;
      case 4:
        null;
        break;
      default:
        throw new Error(" expected 3 or 4 arguments, got " + arity);
    }
    switch (format = (ref = settings['format']) != null ? ref : 'md') {
      case 'md':
        as_html = D.MD.$as_html();
        break;
      case 'html':
        as_html = D.$pass_through();
        break;
      default:
        return handler(new Error("unknown format " + (rpr(format))));
    }
    app = app_;
    matter = app['matter'];
    jQuery = app['jQuery'];
    MKTS = app['MKTS'];
    window = app['window'];
    document = window['document'];
    BD = window['BD'];
    gcolumn = (jQuery('galley column')).eq(0);
    gcolumn_offset = gcolumn.offset();
    gcolumn_left = gcolumn_offset['left'];
    gcolumn_top = gcolumn_offset['top'];
    zoomer = jQuery('zoomer');
    input = D.create_throughstream();
    mark_chrs = true;
    mark_lines = false;
    XXX_t0 = +new Date();
    XXX_times = [];
    input.pipe(as_html).pipe($((function(_this) {
      return function(html, send) {
        XXX_times.push(["html from markdown", new Date() - XXX_t0]);
        send(HOTMETAL.HTML.parse(html));
        return XXX_times.push(["html parsed into hotml", new Date() - XXX_t0]);
      };
    })(this))).pipe($((function(_this) {
      return function(document_hotml, send) {

        /* split document into blocks */
        return HOTMETAL.slice_toplevel_tags(document_hotml, function(error, block_hotml) {
          if (error != null) {
            send.error(error);
          }
          return send(block_hotml);
        });
      };
    })(this))).pipe($((function(_this) {
      return function(block_hotml, send) {

        /* TAINT use HOTMETAL library method */

        /* Wrap block contents in `w` tags used to measure line width;
        method analoguous to `jQuery.wrapInner`
         */
        var first_shred, last_shred;
        warn('#######################################################################');
        first_shred = block_hotml[0];
        last_shred = block_hotml[block_hotml.length - 1];
        first_shred[0].push(['w', {}]);
        last_shred[2].unshift(['w']);
        return send(block_hotml);
      };
    })(this))).pipe(this.$get_slugs(gcolumn)).pipe(this.$xxx()).pipe(D.$on_end(function() {

      /* show some text metrics */
      var description, dt, i, j, len, len1, name, names, ref1, style;
      style = window.getComputedStyle((jQuery('p.slug')).get(0));
      names = "font fontFamily fontKerning fontSize fontStretch fontStyle fontVariant fontVariantLigatures\nfontWeight wordSpacing letterSpacing".split(/\s+/);
      for (i = 0, len = names.length; i < len; i++) {
        name = names[i];
        help(name, style[name]);
      }

      /* !!! */
      XXX_times.push(["finished", new Date() - XXX_t0]);
      for (j = 0, len1 = XXX_times.length; j < len1; j++) {
        ref1 = XXX_times[j], description = ref1[0], dt = ref1[1];
        debug('©1enOB', description, (dt / 1000).toFixed(3));
      }
      return handler();
    }));
    input.write(md);
    return input.end();
  };

  this._demo_pop_over = function() {
    var columns, i, idx, target_columns;
    target_columns = jQuery('page column');
    columns = [];
    for (idx = i = 0; i <= 2; idx = ++i) {
      columns.push(COLUMN.new_column(target_columns.eq(idx), '.slug'));
    }
    debug('©1rmzT', columns[0].length, columns[1].length, columns[2].length);
    COLUMN.pop_over(columns[0], columns[1], 1);
    return debug('©1rmzT', columns[0].length, columns[1].length);
  };

  this._demo_pop_over_async = function() {
    var column, column_idx, column_linecounts, columns, columns_per_page, i, line_count, ref, target_columns;
    target_columns = jQuery('page column');
    columns = [];

    /* TAINT arbitrary constant */
    columns_per_page = 3;
    line_count = 0;
    for (column_idx = i = 0, ref = columns_per_page; 0 <= ref ? i < ref : i > ref; column_idx = 0 <= ref ? ++i : --i) {
      column = COLUMN.new_column(target_columns.eq(column_idx), '.slug');
      line_count += column['length'];
      columns.push(column);
    }
    column_linecounts = this.get_column_linecounts('even', line_count, columns_per_page);
    debug('©rnC7h', column_linecounts);
    return step((function(_this) {
      return function*(resume) {
        var j, ref1, results;
        results = [];
        for (column_idx = j = 0, ref1 = columns_per_page; 0 <= ref1 ? j < ref1 : j > ref1; column_idx = 0 <= ref1 ? ++j : --j) {
          column = columns[column_idx];
          results.push((yield* (function*() {
            var results1;
            results1 = [];
            while (column['length'] > column_linecounts[column_idx]) {

              /* TAINT invalid last column idx */
              results1.push((yield COLUMN.pop_over_async(columns[column_idx], columns[column_idx + 1], 1, resume)));
            }
            return results1;
          })()));
        }
        return results;
      };
    })(this));
  };

}).call(this);
