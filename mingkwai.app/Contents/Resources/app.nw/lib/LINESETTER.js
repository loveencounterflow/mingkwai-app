// Generated by CoffeeScript 1.9.0
(function() {
  var $, CND, D, HOTMETAL, after, alert, badge, debug, echo, help, info, log, rpr, sleep, step, suspend, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/LINESETTER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  sleep = suspend.sleep;

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  HOTMETAL = D.HOTMETAL;

  this.experimental_line_metrics = function() {
    var save_line;
    return save_line = (function(_this) {
      return function(hotml, is_first, is_last) {

        /* Inserts text line into document */
        var a, avg_lws_ratio_pc, chunk, chunk_idx, close_tags, color, idx, is_last_chunk, line, line_width_px, lws, lws_width_px, lws_width_px_avg, material, material_ratio_pc, material_width_px, open_tags, text, _i, _j, _len, _ref;
        for (chunk_idx = _i = 0, _len = hotml.length; _i < _len; chunk_idx = ++_i) {
          chunk = hotml[chunk_idx];
          open_tags = chunk[0], text = chunk[1], close_tags = chunk[2];
          if (text[0] === '<') {
            continue;
          }
          is_last_chunk = chunk_idx >= hotml.length - 1;
          if (chunk_idx !== 0) {
            text = text.replace(/^(\s+)/, "<span class='mkts-lws'>$1</span>");
          }
          if (!is_last_chunk) {
            text = text.replace(/(\s+)$/, "<span class='mkts-lws'>$1</span>");
          }

          /* TAINT not a good implementation */
          if ((text.indexOf("<span class='mkts-lws'>")) === -1) {
            text = "<span class='mkts-material'>" + text + "</span>";
          }
          chunk[1] = text;
        }
        line = get_line(hotml, is_first, is_last);
        container.append(line);

        /*
        http://stackoverflow.com/a/16072668/256361:
        ( ( lws.get idx ).getBoundingClientRect().width for idx in [ 0 .. lws.length - 1 ] )
        http://stackoverflow.com/a/16072449/256361:
        window.getComputedStyle(element).width
         */
        line_width_px = line.width();
        lws = line.find('.mkts-lws');
        debug();
        debug('©RwY5D', line.text());
        if (lws.length > 0) {
          lws_width_px = 0;
          for (idx = _j = 0, _ref = lws.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; idx = 0 <= _ref ? ++_j : --_j) {
            lws_width_px += (lws.eq(idx)).width();
          }
          lws_width_px_avg = lws_width_px / lws.length;
          avg_lws_ratio_pc = a = lws_width_px_avg / line_width_px * 100;
          color = a < 10 ? 'green' : (a < 20 ? 'orange' : 'red');
          debug('Ratio of average inter word spaces to column width:', (avg_lws_ratio_pc.toFixed(1)) + '% ', CND[color]('█'));
        } else {
          material = line.find('.mkts-material');
          if (material.length === 0) {
            warn("no LWS, no material found for line " + (rpr(line.outerHTML())));
          } else {
            material_width_px = material.width();
            material_ratio_pc = material_width_px / line_width_px * 100 - 100;
            a = Math.abs(material_ratio_pc);
            color = a < 10 ? 'green' : (a < 20 ? 'orange' : 'red');
            debug('Ratio of material                  to column width:', (material_ratio_pc.toFixed(1)) + '% ', CND[color]('█'));
          }
        }
        return null;
      };
    })(this);
  };

  this.demo = function(app, md) {
    var MKTS, available_height, bottom_of, bounding_rectangle_of, column_count, column_idx, columns, container, distribute_lines, get_class, get_line, has_hanging_margin, has_warned, height_of, input, jQuery, last_line_height, line_count, live, mm_from_px, new_line_entry, page, relative_bottom_of, relative_top_of, seen_lines, set_lines, style_of, t0, test_line, top_of, window;
    jQuery = app['jQuery'];
    MKTS = app['MKTS'];
    window = app['window'];
    page = (jQuery('.page')).eq(0);
    container = jQuery('.flex-columns-wrap');
    columns = container.find('.column');
    column_count = columns.length;
    seen_lines = null;
    last_line_height = null;
    mm_from_px = function(px) {
      return (px * app['mm-per-px']).toFixed(1);
    };
    new_line_entry = function(line, height) {
      var R;
      R = {
        '%self': line,
        'height': height
      };
      return R;
    };
    has_hanging_margin = function(hotml) {
      var last_chr;
      last_chr = CND.last_of((CND.last_of(hotml))[1].replace(/\s+$/, ''));
      return last_chr === '\u00ad' || last_chr === '-' || last_chr === ',' || last_chr === '.' || last_chr === '!' || last_chr === '—' || last_chr === '–' || last_chr === ':' || last_chr === ';' || last_chr === '(' || last_chr === ')';
    };
    get_class = function(is_first, is_last) {
      if (is_first) {
        if (is_last) {
          return 'is-lone';
        }
        return 'is-first';
      }
      if (is_last) {
        return 'is-last';
      }
      return 'is-middle';
    };
    get_line = function(hotml, is_first, is_last) {
      var R, left_cork, line, right_cork;
      if (typeof R !== "undefined" && R !== null) {
        return (R = seen_lines.get(hotml));
      }
      line = jQuery(HOTMETAL.as_html(hotml));
      line.addClass(get_class(is_first, is_last));
      if (has_hanging_margin(hotml)) {
        line.addClass('hangs-right-05ex');
      }
      line.wrapInner(jQuery("<span class='text-wrapper'></span>"));
      left_cork = jQuery("<span class='cork'></span>");
      right_cork = jQuery("<span class='cork'></span>");
      R = [left_cork, line, right_cork];
      line.prepend(left_cork);
      line.append(right_cork);
      seen_lines.set(hotml, R);
      return R;
    };
    style_of = function(element) {
      return window.getComputedStyle(element.get(0));
    };
    bounding_rectangle_of = function(element) {
      return (element.get(0)).getBoundingClientRect();
    };
    height_of = function(element) {

      /* jQuery rounds to integer pixels, this is more precise. */
      var height, style;
      style = style_of(element);
      height = parseFloat(style['height']);
      if (!isFinite(height)) {
        height = (bounding_rectangle_of(element))['height'];
      }
      return height - (parseFloat(style['border-top-width'])) - (parseFloat(style['border-bottom-width'])) - (parseFloat(style['margin-top'])) - (parseFloat(style['margin-bottom'])) - (parseFloat(style['padding-top'])) - (parseFloat(style['padding-bottom']));
    };
    top_of = function(element) {
      return window.scrollY + (bounding_rectangle_of(element))['top'];
    };
    bottom_of = function(element) {
      return (top_of(element)) + height_of(element);
    };
    relative_top_of = function(element, selector) {
      return (top_of(element)) - (top_of(element.parents(selector)));
    };
    relative_bottom_of = function(element, selector) {
      return (relative_top_of(element, selector)) + height_of(element);
    };
    window.height_of = height_of;
    window.bottom_of = bottom_of;
    window.top_of = top_of;
    window.relative_bottom_of = relative_bottom_of;
    window.relative_top_of = relative_top_of;
    line_count = 0;
    available_height = height_of(jQuery('.flex-columns-wrap'));
    column_idx = 0;
    has_warned = false;
    test_line = function(action, hotml, is_first, is_last) {

      /* Must return whether HTML fits into one line. */
      var R, bottom, left_cork, line, right_cork, _, _ref, _ref1;
      switch (action) {
        case 'set':
          if (column_idx <= column_count - 1) {
            _ref = get_line(hotml, is_first, is_last), _ = _ref[0], line = _ref[1], _ = _ref[2];
            (line.find('.cork')).detach();
            (columns.eq(column_idx)).append(line);
            bottom = relative_bottom_of(line.find('.text-wrapper'), '.flex-columns-wrap');
            if (available_height - bottom < 0) {
              line.detach();
              column_idx += +1;
              if (column_idx > column_count - 1) {
                if (!has_warned) {
                  warn("next page");
                }
                has_warned = true;
              } else {
                (columns.eq(column_idx)).append(line);
              }
            }
          }
          return line_count += +1;
        case 'test':
          process.stdout.write('.');
          _ref1 = get_line(hotml, is_first, is_last), left_cork = _ref1[0], line = _ref1[1], right_cork = _ref1[2];
          (columns.eq(0)).append(line);
          R = left_cork.offset()['top'] === right_cork.offset()['top'];
          line.detach();
          return R;
        default:
          throw new Error("unknown action " + (rpr(action)));
      }
    };
    distribute_lines = function() {
      var R, column_line_height, column_linecounts, line, line_entry, line_height, line_idx, page_height, total_line_height, _i, _len;
      page_height = height_of(page);
      column_line_height = 0;
      total_line_height = 0;
      column_idx = 0;
      column_linecounts = [0, 0, 0];
      R = {
        '~isa': 'LINESETTER/line-distribution',
        'column-linecounts': column_linecounts,
        'page-count': 1,
        'distributions': []
      };
      for (line_idx = _i = 0, _len = saved_lines.length; _i < _len; line_idx = ++_i) {
        line_entry = saved_lines[line_idx];
        line = line_entry['%self'];
        line_height = line_entry['height'];
        if (column_idx === 0) {
          debug('©LDasJ', line_idx + 1, line_height, column_line_height + line_height, page_height - column_line_height - line_height, line.text());
        }
        if (column_line_height + line_height > page_height) {
          column_line_height = 0;
          if (column_idx < column_count - 1) {
            column_idx += 1;
            column_line_height = 0;
          } else {
            R['page-count'] += +1;
          }
        } else {
          column_linecounts[column_idx] += +1;
          total_line_height += line_height;
          column_line_height += line_height;
        }
      }
      return R;
    };
    set_lines = function(live, handler) {
      if (live == null) {
        live = false;
      }
      return handler(null);
      step((function(_this) {
        return function*(resume) {

          /* TAINT assuming we have an entire blank page */
          var column, column_linecount, column_linecounts, count, line, line_entry, _i, _j, _len, _len1, _ref;
          line_count = saved_lines.length;
          column_linecounts = HOTMETAL.get_column_linecounts('even', line_count, 3);
          help("line count: " + line_count);
          help("column line counts: " + column_linecounts);

          /* TAINT simplify */
          count = 0;
          for (column_idx = _i = 0, _len = column_linecounts.length; _i < _len; column_idx = ++_i) {
            column_linecount = column_linecounts[column_idx];
            column = columns.eq(column_idx);
            _ref = saved_lines.slice(count, count + column_linecount);
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              line_entry = _ref[_j];
              line = line_entry['%self'];
              if (live) {
                (yield MKTS.wait(resume));
              }
              column.append(line);
            }
            count += column_linecount;
          }
          return handler(null);
        };
      })(this));
      return null;
    };
    input = D.create_throughstream();
    live = true;
    live = false;
    t0 = 1 * new Date();
    input.pipe(D.TYPO.$quotes()).pipe(D.TYPO.$dashes()).pipe(D.MD.$as_html()).pipe(D.HTML.$parse()).pipe(D.HTML.$slice_toplevel_tags()).pipe($((function(_this) {
      return function(block_hotml, send) {
        return send(block_hotml);
      };
    })(this))).pipe((function(_this) {
      return function() {
        line_count = 0;
        return $(function(block_hotml, send, end) {
          return step(function*(resume) {
            var dt, t1;
            if (block_hotml != null) {
              seen_lines = new WeakMap();
              HOTMETAL.break_lines(block_hotml, test_line);
              send(block_hotml);
            }
            if (end != null) {
              (yield set_lines(live, resume));
              warn('ended');
              t1 = 1 * new Date();
              dt = t1 - t0;
              return debug('©h9n6j', dt);
            }
          });
        });
      };
    })(this)());
    input.write(md);
    return input.end();
  };

}).call(this);
