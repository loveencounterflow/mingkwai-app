// Generated by CoffeeScript 1.9.0
(function() {
  var CHR, D2, LINESETTER, MKTS, NW, TRM, after, alert, app, badge, bindings, build_menu, debug, echo, help, info, keyboard, log, njs_fs, njs_path, on_file_menu_what_you_should_know_C, rpr, sleep, step, suspend, urge, warn, whisper, win;

  njs_path = require('path');

  njs_fs = require('fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '眀快排字机/browser';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  urge = TRM.get_logger('urge', badge);

  whisper = TRM.get_logger('whisper', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  NW = require('nw.gui');

  win = NW.Window.get();

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  after = suspend.after;

  sleep = suspend.sleep;

  D2 = require('pipedreams2');

  CHR = require('coffeenode-chr');

  LINESETTER = require('./LINESETTER');

  help("app data path is " + NW.App.dataPath);

  MKTS = {};

  app = {
    'zoom-level': 0
  };

  on_file_menu_what_you_should_know_C = function() {
    return ($('#content')).text("Some kind of interesting stuff.");
  };

  build_menu = function() {
    var edit_menu_item, file_menu, file_menu_entry, help_menu, help_menu_entry, win_menu;
    help_menu = new NW.Menu();
    help_menu.append(new NW.MenuItem({
      label: 'about 眀快排字机'
    }));
    help_menu.append(new NW.MenuItem({
      label: 'what you should know A'
    }));
    help_menu_entry = new NW.MenuItem({
      label: 'Help',
      'submenu': help_menu
    });
    file_menu = new NW.Menu();
    file_menu.append(new NW.MenuItem({
      label: 'New'
    }));
    file_menu.append(new NW.MenuItem({
      label: 'Open...',
      click: on_file_menu_what_you_should_know_C
    }));
    file_menu.append(new NW.MenuItem({
      label: 'Save',
      key: 's',
      modifiers: 'cmd',
      click: function() {
        return urge("saving...");
      }
    }));
    file_menu.append(new NW.MenuItem({
      label: 'Take Screenshot',
      key: 's',
      modifiers: 'cmd-shift',
      click: function() {
        return MKTS.take_screenshot(app);
      }
    }));
    file_menu_entry = new NW.MenuItem({
      label: 'File',
      'submenu': file_menu
    });
    win_menu = new NW.Menu({
      type: 'menubar'
    });
    win_menu.createMacBuiltin('眀快排字机');
    win_menu.insert(file_menu_entry, 1);
    win_menu.append(help_menu_entry);
    win.menu = win_menu;
    edit_menu_item = win.menu.items[2];
    TRM.dir(edit_menu_item);
    TRM.dir(edit_menu_item.submenu);
    edit_menu_item.submenu.insert(new NW.MenuItem({
      label: 'xxxxxxxxx'
    }), 1);
    debug('©RsQep', edit_menu_item.type);
    return null;
  };

  build_menu();

  win.show();

  win.focus();

  win.zoomLevel = 0;

  win.setResizable(true);

  win.on('close', function() {
    info('close');
    return this.close(true);
  });

  MKTS.get_document_size = function(me) {
    return [($('html')).outerWidth(), ($('html')).outerHeight()];
  };

  MKTS.maximize = function(app) {
    win.moveTo(window.screen.availLeft, window.screen.availTop);
    return win.resizeTo(window.screen.availWidth, window.screen.availHeight);
  };

  win.on('document-end', function() {
    return step(function*(resume) {
      var last_html, lines, source, take_line, test_line;
      MKTS.zoom_to(app, 1.85);
      (yield step.wrap(($('document')).ready, resume));
      help("document ready");
      ($(document)).keydown(MKTS.on_keydown.bind(MKTS));
      source = "<p>The <b class='x'>Dormouse</b> <u>was <i>inexplicably</i> falling asleep</u> <i>again</i>.</p>";
      source = "The <b class='x'>Dormouse</b> 眀快排字机 <u>was <i>inexplicably falling asleep</i></u> <i>again</i>.";
      last_html = null;
      lines = [];
      test_line = function(html) {
        var corks, dy, line;
        line = $("<div class='mkts-lineprobe'><span class='cork'></span>" + html + "<span class='cork'></span></div>");
        corks = line.find('.cork');
        ($('#box-a p')).append(line);
        dy = (corks.eq(1)).offset()['top'] - (corks.eq(0)).offset()['top'];
        if (dy !== 0) {
          if (last_html != null) {
            lines.push(last_html);
            return true;
          } else {
            warn("line too long: " + (rpr(html)));
            return null;
          }
        }
        last_html = html;
        return false;
      };
      take_line = function(line) {
        if (line != null) {
          return lines.push(line);
        } else {
          return help(lines);
        }
      };
      return (yield LINESETTER.set_lines(source, test_line, take_line, resume));
    });
  });

  MKTS.zoom_to = function(me, level) {

    /* TAINT code duplication */
    var base_zoom_level, zoom_percent;
    base_zoom_level = -0.15;
    win.zoomLevel = level != null ? level : base_zoom_level;
    zoom_percent = (win.zoomLevel - base_zoom_level) * 1.2 * 100;
    echo("zoomed to level " + win.zoomLevel + " (" + (zoom_percent.toFixed(0)) + "%)");
    return win.zoomLevel;
  };

  MKTS.zoom = function(me, delta) {
    var base_zoom_level, zoom_percent;
    base_zoom_level = -0.15;
    if (delta != null) {
      if ((delta > 0 && win.zoomLevel <= 8.8) || (delta < 0 && win.zoomLevel >= -7.5)) {
        win.zoomLevel += delta;
      }
    } else {
      win.zoomLevel = base_zoom_level;
    }
    zoom_percent = (win.zoomLevel - base_zoom_level) * 1.2 * 100;
    echo("zoomed to level " + win.zoomLevel + " (" + (zoom_percent.toFixed(0)) + "%)");
    return win.zoomLevel;
  };

  MKTS.print = function() {
    return print();
  };

  MKTS.wait = function(handler) {
    return window.requestAnimationFrame(function() {
      return handler();
    });
  };

  MKTS.take_screenshot = function() {
    return step((function(_this) {
      return function*(resume) {

        /* trying to wait for DOM reflow: */
        var img, img_route;
        (yield MKTS.wait(resume));
        img = (yield MKTS._capture(win, resume));
        img_route = '/tmp/nw.png';
        (yield njs_fs.writeFile(img_route, img, resume));
        return help("image written to " + img_route);
      };
    })(this));
  };

  MKTS.scroll_to = function(label) {
    return ($('html, body')).stop().animate({
      scrollTop: ($(label)).offset().top
    }, 500);
  };

  MKTS.scroll_to_top = function() {
    return this.scroll_to('#mkts-top');
  };

  MKTS.scroll_to_bottom = function() {
    return this.scroll_to('#mkts-bottom');
  };

  MKTS._capture = function(win, handler) {
    return win.capturePage(((function(_this) {
      return function(img) {
        return handler(null, img);
      };
    })(this)), {
      format: 'png',
      datatype: 'buffer'
    });
  };

  MKTS.foo = function(event) {
    return debug('©9HvgT', 'xxxx');
  };

  keyboard = new Map();

  keyboard.set(187, 'plus');

  keyboard.set(189, 'minus');

  keyboard.set(221, 'asterisk');

  keyboard.set(48, '0');

  keyboard.set(80, 'p');

  keyboard.set(81, 'q');

  keyboard.set(82, 'r');

  keyboard.set(83, 's');

  keyboard.set(89, 'y');

  keyboard.set(37, 'left');

  keyboard.set(39, 'right');

  bindings = {
    'meta+plus': function() {
      return MKTS.zoom(app, +1);
    },
    'meta+shift+asterisk': function() {
      return MKTS.zoom(app, +0.1);
    },
    'meta+0': function() {
      return MKTS.zoom(app, null);
    },
    'meta+minus': function() {
      return MKTS.zoom(app, -1);
    },
    'meta+shift+minus': function() {
      return MKTS.zoom(app, -0.1);
    },
    'meta+p': function() {
      return MKTS.print();
    },
    'meta+left': function() {
      return MKTS.scroll_to_top();
    },
    'meta+right': function() {
      return MKTS.scroll_to_bottom();
    },
    'meta+y': function() {}
  };

  MKTS._TRY_balanced_columns = function() {
    var column_count, columns, focus, focus_idx, hilite, is_demo, last_left, line_offset, line_offsets, new_focus, new_line_offset, new_range, range, text_node;
    last_left = null;
    focus_idx = -1;
    text_node = ($('#box-a p')).contents().get(0);
    debug('©09SY6', 'content element count:', ($('#box-a p')).contents().length);
    columns = $('.flex-columns-wrap .column');
    column_count = columns.length;
    debug('©AT6uj', column_count + " columns");
    line_offsets = [];

    /* TAINT must recompute on zoom */
    hilite = function(focus, rectangle) {
      focus.offset(rectangle);
      focus.width(rectangle['width']);
      return focus.height(rectangle['height']);
    };
    new_range = function(start) {
      var R;
      if (text_node == null) {
        throw new Error("text_node not defined");
      }
      R = document.createRange();
      R.setStart(text_node, start);
      R.setEnd(text_node, start);
      return R;
    };
    new_focus = function() {
      var R;
      focus_idx += +1;
      R = $("<div class='focus' id='focus-" + focus_idx + "'></div>");
      ($('html')).append(R);
      return R;
    };
    new_line_offset = function() {
      var R;
      line_offsets.push(R = [null, null]);
      return R;
    };
    is_demo = true;
    range = new_range(0);
    focus = new_focus();
    line_offset = new_line_offset();
    line_offset[0] = 0;
    return step((function(_this) {
      return function*(resume) {
        var column_idx, column_linecount, column_linecounts, column_text, corrected_end_idx, end_idx, first_idx, last_idx, left, line_count, line_offset_idx, rectangle, text, _i, _j, _ref, _results, _text_node;
        for (end_idx = _i = 1, _ref = text_node.length; 1 <= _ref ? _i <= _ref : _i >= _ref; end_idx = 1 <= _ref ? ++_i : --_i) {
          range.setEnd(text_node, end_idx);
          line_offset[1] = end_idx;
          rectangle = range.getBoundingClientRect();
          left = rectangle.left;
          if (last_left === 0) {
            last_left = left;
          } else if ((last_left != null) && left > last_left) {
            corrected_end_idx = end_idx - 1;
            range.setEnd(text_node, corrected_end_idx);
            line_offset[1] = corrected_end_idx;
            hilite(focus, range.getBoundingClientRect());
            debug('©pwdqt', end_idx, line_offset, rpr(range.toString()));
            range = new_range(corrected_end_idx);
            line_offset = new_line_offset();
            line_offset[0] = corrected_end_idx;
            line_offset[1] = corrected_end_idx;
            focus = new_focus();
            rectangle = range.getBoundingClientRect();
            if (is_demo) {
              (yield after(0.05, resume));
            }
          }
          last_left = rectangle['left'];
          hilite(focus, rectangle);
        }
        debug('©OE1Vx', end_idx, line_offset, rpr(range.toString()));
        line_count = line_offsets.length;
        column_linecounts = MKTS.get_column_linecounts('even', line_count, column_count);
        text = ($(text_node)).text();

        /* TAINT use jQuery? */
        line_offset_idx = 0;
        _results = [];
        for (column_idx = _j = 0; 0 <= column_count ? _j < column_count : _j > column_count; column_idx = 0 <= column_count ? ++_j : --_j) {
          column_linecount = column_linecounts[column_idx];
          if (column_linecount < 1) {
            continue;
          }
          _text_node = ((($('.flex-columns-wrap .column')).eq(column_idx)).find('p')).contents().get(0);
          first_idx = line_offsets[line_offset_idx][0];
          last_idx = line_offsets[line_offset_idx + column_linecount - 1][1];
          line_offset_idx += column_linecount;
          column_text = text.slice(first_idx, last_idx);

          /* TAINT should mark as 'originally a soft hyphen' in case of later text re-flow? */
          column_text = column_text.replace(/\u00ad$/, '-');
          _text_node.nodeValue = column_text;
          if (is_demo) {
            _results.push((yield after(0.5, resume)));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
    })(this));
  };


  /*
  
  foo <b><i>is it</i> really</b> baz
  
  'foo'
  'foo', ' '
  'foo', ' ', <b><i>, 'is', ⬇, ⬇
  'foo', ' ', <b><i>, 'is', ' ', ⬇, ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', 'really', ⬇
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', 'really', ⬇, ' '
  'foo', ' ', <b><i>, 'is', ' ', 'it', ⬇, ' ', 'really', ⬇, ' ', 'baz'
  
  'foo'
  'foo '
  'foo <b><i>is</i></b>'
  'foo <b><i>is </i></b>'
  'foo <b><i>is it</i></b>'
  'foo <b><i>is it</i> </b>'
  'foo <b><i>is it</i> really</b>'
  'foo <b><i>is it</i> really</b> '
  'foo <b><i>is it</i> really</b> baz'
   */

  MKTS.get_column_linecounts = function(strategy, line_count, column_count) {

    /* thx to http://stackoverflow.com/a/1244369/256361 */
    var R, col, _i;
    R = [];
    switch (strategy) {
      case 'even':
        for (col = _i = 1; 1 <= column_count ? _i <= column_count : _i >= column_count; col = 1 <= column_count ? ++_i : --_i) {
          R.push(Math.floor((line_count + column_count - col) / column_count));
        }
        break;
      default:
        throw new Error("unknown strategy " + (rpr(strategy)));
    }
    return R;
  };

  MKTS.on_keydown = function(event) {
    var binding, code, key_name, _ref, _ref1;
    code = (_ref = event.keyCode) != null ? _ref : event.which;
    key_name = [];
    if (event.altKey) {
      key_name.push('alt');
    }
    if (event.ctrlKey) {
      key_name.push('ctrl');
    }
    if (event.metaKey) {
      key_name.push('meta');
    }
    if (event.shiftKey) {
      key_name.push('shift');
    }
    key_name.push((_ref1 = keyboard.get(code)) != null ? _ref1 : code);
    key_name = key_name.join('+');
    echo(rpr(key_name), code);
    if ((binding = bindings[key_name]) != null) {
      binding();
      return false;
    } else {
      return true;
    }
  };

}).call(this);
