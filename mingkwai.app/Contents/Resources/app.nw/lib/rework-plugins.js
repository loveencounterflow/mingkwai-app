// Generated by CoffeeScript 1.9.1
(function() {
  var CND, alert, badge, debug, help, info, log, njs_fs, njs_path, rpr, urge, walk_rules, warn, whisper,
    slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/rework-plugins';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  walk_rules = function(ast, handler) {
    var entry, i, j, len, len1, media, ref, ref1, rule, rules, type;
    ref = ast['rules'];
    for (i = 0, len = ref.length; i < len; i++) {
      entry = ref[i];
      type = entry.type;
      switch (type) {
        case 'media':
          media = entry.media, rules = entry.rules;
          ref1 = entry['rules'];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            rule = ref1[j];
            handler(null, media, rule);
          }
          break;
        case 'rule':
          handler(null, '*', entry);
          break;
        case 'font-face':
        case 'comment':
          null;
          break;
        default:
          return handler(new Error("unknown type " + (rpr(type))));
      }
    }
  };

  this.foobar_super = function() {
    return (function(_this) {
      return function(ast, rw) {
        var declaration, declarations, i, len, position, property, ref, ref1, results, selectors, value;
        ref = ast['rules'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          ref1 = ref[i], selectors = ref1.selectors, declarations = ref1.declarations, position = ref1.position;
          if (declarations == null) {
            continue;
          }
          results.push((function() {
            var j, len1, results1;
            results1 = [];
            for (j = 0, len1 = declarations.length; j < len1; j++) {
              declaration = declarations[j];
              property = declaration.property, value = declaration.value;
              if (!/^foobar$/.test(property)) {
                continue;
              }
              results1.push(declaration['property'] = '-moz-supercssyeah');
            }
            return results1;
          })());
        }
        return results;
      };
    })(this);
  };

  this.collect = function() {
    var Z, handler, i, matchers, rules, s;
    matchers = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), handler = arguments[i++];

    /* Collect all matching properties and call handler with a list of matched CSS declarations; each
    declaration will be a pod `{ selectors, property, value, }`.
     */
    matchers = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = matchers.length; j < len; j++) {
        s = matchers[j];
        results.push([s, CND.type_of(s)]);
      }
      return results;
    })();
    rules = [];
    Z = {
      '%selectors': {},
      'rules': rules
    };
    return (function(_this) {
      return function(ast) {
        walk_rules(ast, function(error, media, rule) {
          var base, declaration, declarations, idx, j, k, l, len, len1, len2, matcher, property, ref, selector, selectors, type, value;
          if (error != null) {
            throw error;
          }
          selectors = rule.selectors, declarations = rule.declarations;
          for (j = 0, len = declarations.length; j < len; j++) {
            declaration = declarations[j];
            property = declaration.property, value = declaration.value;
            for (k = 0, len1 = matchers.length; k < len1; k++) {
              ref = matchers[k], matcher = ref[0], type = ref[1];
              switch (type) {
                case 'text':
                  if (property !== matcher) {
                    continue;
                  }
                  break;
                case 'jsregex':
                  if (!matcher.test(property)) {
                    continue;
                  }
                  break;
                default:
                  return handler(new Error("unknown matcher type " + (rpr(type))));
              }
              rules.push({
                media: media,
                selectors: selectors,
                property: property,
                value: value
              });
              idx = rules.length - 1;

              /* TAINT selectors not properly ordered */
              for (l = 0, len2 = selectors.length; l < len2; l++) {
                selector = selectors[l];
                ((base = Z['%selectors'])[selector] != null ? base[selector] : base[selector] = []).push(idx);
              }
            }
          }
        });
        return handler(null, Z);
      };
    })(this);
  };

}).call(this);
