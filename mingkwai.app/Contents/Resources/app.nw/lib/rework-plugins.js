// Generated by CoffeeScript 1.9.0
(function() {
  var CND, alert, badge, debug, help, info, log, njs_fs, njs_path, rpr, urge, walk_rules, warn, whisper,
    __slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = '眀快排字机/rework-plugins';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  walk_rules = function(ast, handler) {
    var entry, media, rule, rules, type, _i, _j, _len, _len1, _ref, _ref1;
    _ref = ast['rules'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entry = _ref[_i];
      type = entry.type;
      switch (type) {
        case 'media':
          media = entry.media, rules = entry.rules;
          _ref1 = entry['rules'];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            rule = _ref1[_j];
            handler(null, media, rule);
          }
          break;
        case 'rule':
          handler(null, '*', entry);
          break;
        case 'font-face':
        case 'comment':
          null;
          break;
        default:
          return handler(new Error("unknown type " + (rpr(type))));
      }
    }
  };

  this.foobar_super = function() {
    return (function(_this) {
      return function(ast, rw) {
        var declaration, declarations, position, property, selectors, value, _i, _len, _ref, _ref1, _results;
        _ref = ast['rules'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], selectors = _ref1.selectors, declarations = _ref1.declarations, position = _ref1.position;
          if (declarations == null) {
            continue;
          }
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = declarations.length; _j < _len1; _j++) {
              declaration = declarations[_j];
              property = declaration.property, value = declaration.value;
              if (!/^foobar$/.test(property)) {
                continue;
              }
              _results1.push(declaration['property'] = '-moz-supercssyeah');
            }
            return _results1;
          })());
        }
        return _results;
      };
    })(this);
  };

  this.collect = function() {
    var Z, handler, matchers, rules, s, _i;
    matchers = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), handler = arguments[_i++];

    /* Collect all matching properties and call handler with a list of matched CSS declarations; each
    declaration will be a pod `{ selectors, property, value, }`.
     */
    matchers = (function() {
      var _j, _len, _results;
      _results = [];
      for (_j = 0, _len = matchers.length; _j < _len; _j++) {
        s = matchers[_j];
        _results.push([s, CND.type_of(s)]);
      }
      return _results;
    })();
    rules = [];
    Z = {
      '%selectors': {},
      'rules': rules
    };
    return (function(_this) {
      return function(ast) {
        walk_rules(ast, function(error, media, rule) {
          var declaration, declarations, idx, matcher, property, selector, selectors, type, value, _base, _j, _k, _l, _len, _len1, _len2, _ref;
          if (error != null) {
            throw error;
          }
          selectors = rule.selectors, declarations = rule.declarations;
          for (_j = 0, _len = declarations.length; _j < _len; _j++) {
            declaration = declarations[_j];
            property = declaration.property, value = declaration.value;
            for (_k = 0, _len1 = matchers.length; _k < _len1; _k++) {
              _ref = matchers[_k], matcher = _ref[0], type = _ref[1];
              switch (type) {
                case 'text':
                  if (property !== matcher) {
                    continue;
                  }
                  break;
                case 'jsregex':
                  if (!matcher.test(property)) {
                    continue;
                  }
                  break;
                default:
                  return handler(new Error("unknown matcher type " + (rpr(type))));
              }
              rules.push({
                media: media,
                selectors: selectors,
                property: property,
                value: value
              });
              idx = rules.length - 1;
              for (_l = 0, _len2 = selectors.length; _l < _len2; _l++) {
                selector = selectors[_l];
                ((_base = Z['%selectors'])[selector] != null ? _base[selector] : _base[selector] = []).push(idx);
              }
            }
          }
        });
        return handler(null, Z);
      };
    })(this);
  };

}).call(this);
